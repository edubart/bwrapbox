/* Generated by Nelua 0.2.0-dev */
/* Compile command: gcc -x c "bwrapbox.c" -x none -fwrapv -fno-strict-aliasing -g -lm -o "bwrapbox" */
/* Compile hash: qN5XC2Zvo8ZVeVsNe3xjgENHDLf */
/* ------------------------------ DIRECTIVES -------------------------------- */
#include <stdbool.h>
/* Macro used to force inlining a function. */
#ifdef __GNUC__
  #define NELUA_INLINE __attribute__((always_inline)) inline
#elif defined(_MSC_VER)
  #define NELUA_INLINE __forceinline
#elif __STDC_VERSION__ >= 199901L
  #define NELUA_INLINE inline
#else
  #define NELUA_INLINE
#endif
#include <stdint.h>
/* Macro used sign that a type punning cast may alias (related to strict aliasing). */
#ifdef __GNUC__
  #define NELUA_MAYALIAS __attribute__((may_alias))
#else
  #define NELUA_MAYALIAS
#endif
#define NELUA_NIL (nlniltype){}
#include <string.h>
/* Macro used for branch prediction. */
#if defined(__GNUC__) || defined(__clang__)
  #define NELUA_UNLIKELY(x) __builtin_expect(x, 0)
#else
  #define NELUA_UNLIKELY(x) (x)
#endif
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
/* Macro used to import/export extern C functions. */
#ifdef __cplusplus
  #define NELUA_EXTERN extern "C"
#else
  #define NELUA_EXTERN extern
#endif
/* Macro used to generate traceback on aborts when sanitizing. */
#if defined(__clang__) && defined(__has_feature)
  #if __has_feature(undefined_behavior_sanitizer)
    #define NELUA_UBSAN_UNREACHABLE __builtin_unreachable
  #endif
#elif defined(__gnu_linux__) && defined(__GNUC__) && __GNUC__ >= 5
  NELUA_EXTERN void __ubsan_handle_builtin_unreachable(void*) __attribute__((weak));
  #define NELUA_UBSAN_UNREACHABLE() {if(&__ubsan_handle_builtin_unreachable) __builtin_unreachable();}
#endif
#ifndef NELUA_UBSAN_UNREACHABLE
  #define NELUA_UBSAN_UNREACHABLE()
#endif
/* Macro used to specify a function that never returns. */
#if __STDC_VERSION__ >= 201112L
  #define NELUA_NORETURN _Noreturn
#elif defined(__GNUC__)
  #define NELUA_NORETURN __attribute__((noreturn))
#elif defined(_MSC_VER)
  #define NELUA_NORETURN __declspec(noreturn)
#else
  #define NELUA_NORETURN
#endif
/* Macro used for branch prediction. */
#if defined(__GNUC__) || defined(__clang__)
  #define NELUA_LIKELY(x) __builtin_expect(x, 1)
#else
  #define NELUA_LIKELY(x) (x)
#endif
/* Macro used to force not inlining a function. */
#ifdef __GNUC__
  #define NELUA_NOINLINE __attribute__((noinline))
#elif defined(_MSC_VER)
  #define NELUA_NOINLINE __declspec(noinline)
#else
  #define NELUA_NOINLINE
#endif
#include <errno.h>
#include <time.h>
/* Include basic POSIX constants and APIs */
#if !defined(_WIN32) && (defined(__unix__) || defined(__unix) || \
                        (defined(__APPLE__) && defined(__MACH__)) || \
                        defined(__HAIKU__))
  #include <unistd.h>
#endif
/* Include Windows APIs. */
#ifdef _WIN32
  #ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN
  #endif
  #ifndef _WIN32_WINNT
    #define _WIN32_WINNT 0x600
  #endif
  #include <windows.h>
#endif
/* Determine supported high resolution time API. */
#if defined(_POSIX_TIMERS) && defined(_POSIX_MONOTONIC_CLOCK)
  #define NELUA_HAVE_POSIX_MONOTONIC_CLOCK
#elif __STDC_VERSION__ >= 201112L && defined(TIME_UTC) && !defined(__ANDROID__) && !defined(__wasm__)
  #define NELUA_HAVE_C11_TIMESPEC_GET
#elif defined(_POSIX_VERSION)
  #include <sys/time.h>
  #define NELUA_HAVE_POSIX_GETTIMEOFDAY
#endif
#include <signal.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/wait.h>
/* Macro used to take reference of literals. */
#define NELUA_LITERAL_REF(T, x) (&((struct{T v;}){x}.v))
/* ------------------------------ DECLARATIONS ------------------------------ */
typedef struct nelua_span_uint8_ nelua_span_uint8_;
typedef uint8_t* nluint8_arr0_ptr;
struct nelua_span_uint8_ {
  nluint8_arr0_ptr data;
  uintptr_t size;
};
static NELUA_INLINE bool nelua_span_uint8__empty(nelua_span_uint8_ self);
typedef uint8_t* nluint8_ptr;
static NELUA_INLINE nluint8_ptr nelua_span_uint8____atindex(nelua_span_uint8_ self, uintptr_t i);
typedef struct nlstring nlstring;
typedef nlstring* nlstring_ptr;
struct nlstring {
  nluint8_arr0_ptr data;
  uintptr_t size;
};
typedef struct nelua_span_string_ nelua_span_string_;
typedef nlstring* nlstring_arr0_ptr;
struct nelua_span_string_ {
  nlstring_arr0_ptr data;
  uintptr_t size;
};
static NELUA_INLINE nlstring_ptr nelua_span_string____atindex(nelua_span_string_ self, uintptr_t i);
typedef struct NELUA_MAYALIAS nlstring_arr3 {nlstring v[3];} nlstring_arr3;
typedef union NELUA_MAYALIAS nlstring_arr3_cast {nlstring_arr3 a; nlstring p[3];} nlstring_arr3_cast;
typedef nlstring_arr3* nlstring_arr3_ptr;
static NELUA_INLINE nelua_span_string_ nelua_span_string____convert_1(nlstring_arr3_ptr values);
typedef uintptr_t* nlusize_ptr;
typedef struct nelua_span_usize_ nelua_span_usize_;
typedef uintptr_t* nlusize_arr0_ptr;
struct nelua_span_usize_ {
  nlusize_arr0_ptr data;
  uintptr_t size;
};
static NELUA_INLINE nlusize_ptr nelua_span_usize____atindex(nelua_span_usize_ self, uintptr_t i);
typedef struct nelua_hashmapnode_string__cint_ nelua_hashmapnode_string__cint_;
typedef nelua_hashmapnode_string__cint_* nelua_hashmapnode_string__cint__ptr;
struct nelua_hashmapnode_string__cint_ {
  nlstring key;
  int value;
  bool filled;
  uintptr_t next;
};
typedef struct nelua_span_hashmapnode_string__cint__ nelua_span_hashmapnode_string__cint__;
typedef nelua_hashmapnode_string__cint_* nelua_hashmapnode_string__cint__arr0_ptr;
struct nelua_span_hashmapnode_string__cint__ {
  nelua_hashmapnode_string__cint__arr0_ptr data;
  uintptr_t size;
};
static NELUA_INLINE nelua_hashmapnode_string__cint__ptr nelua_span_hashmapnode_string__cint_____atindex(nelua_span_hashmapnode_string__cint__ self, uintptr_t i);
typedef struct bwrapbox_limit_pair bwrapbox_limit_pair;
typedef bwrapbox_limit_pair* bwrapbox_limit_pair_ptr;
struct bwrapbox_limit_pair {
  nlstring name;
  int64_t value;
};
typedef struct nelua_span_limit_pair_ nelua_span_limit_pair_;
typedef bwrapbox_limit_pair* bwrapbox_limit_pair_arr0_ptr;
struct nelua_span_limit_pair_ {
  bwrapbox_limit_pair_arr0_ptr data;
  uintptr_t size;
};
static NELUA_INLINE bwrapbox_limit_pair_ptr nelua_span_limit_pair____atindex(nelua_span_limit_pair_ self, uintptr_t i);
typedef char** nlcstring_ptr;
typedef struct nelua_span_cstring_ nelua_span_cstring_;
typedef char** nlcstring_arr0_ptr;
struct nelua_span_cstring_ {
  nlcstring_arr0_ptr data;
  uintptr_t size;
};
static NELUA_INLINE nlcstring_ptr nelua_span_cstring____atindex(nelua_span_cstring_ self, uintptr_t i);
typedef struct nlmulret_nlboolean_nlint64_bwrapbox_limit_pair {
  bool r1;
  int64_t r2;
  bwrapbox_limit_pair r3;
} nlmulret_nlboolean_nlint64_bwrapbox_limit_pair;
typedef struct nelua_sequence_limit_pair_ nelua_sequence_limit_pair_;
typedef struct nelua_sequenceimpl_limit_pair_ nelua_sequenceimpl_limit_pair_;
typedef nelua_sequenceimpl_limit_pair_* nelua_sequenceimpl_limit_pair__ptr;
typedef struct nelua_GeneralAllocator nelua_GeneralAllocator;
struct nelua_GeneralAllocator {};
struct nelua_sequence_limit_pair_ {
  nelua_sequenceimpl_limit_pair__ptr impl;
  nelua_GeneralAllocator allocator;
};
typedef nlmulret_nlboolean_nlint64_bwrapbox_limit_pair (*function_3cvqKRRWFe2qk8ZgD)(nelua_sequence_limit_pair_, int64_t);
struct nelua_sequenceimpl_limit_pair_ {
  nelua_span_limit_pair_ data;
  uintptr_t size;
};
typedef struct nlmulret_function_3cvqKRRWFe2qk8ZgD_nelua_sequence_limit_pair__nlint64 {
  function_3cvqKRRWFe2qk8ZgD r1;
  nelua_sequence_limit_pair_ r2;
  int64_t r3;
} nlmulret_function_3cvqKRRWFe2qk8ZgD_nelua_sequence_limit_pair__nlint64;
static NELUA_INLINE nlmulret_function_3cvqKRRWFe2qk8ZgD_nelua_sequence_limit_pair__nlint64 nelua_ipairs_1(nelua_sequence_limit_pair_ a);
static NELUA_INLINE nlmulret_nlboolean_nlint64_bwrapbox_limit_pair nelua_ipairs_next(nelua_sequence_limit_pair_ a_1, int64_t k);
typedef struct nlmulret_nlboolean_nlint64_nlstring {
  bool r1;
  int64_t r2;
  nlstring r3;
} nlmulret_nlboolean_nlint64_nlstring;
typedef struct nelua_sequence_string__1 nelua_sequence_string__1;
typedef struct nelua_sequenceimpl_string__1 nelua_sequenceimpl_string__1;
typedef nelua_sequenceimpl_string__1* nelua_sequenceimpl_string__1_ptr;
struct nelua_sequence_string__1 {
  nelua_sequenceimpl_string__1_ptr impl;
  nelua_GeneralAllocator allocator;
};
typedef nlmulret_nlboolean_nlint64_nlstring (*function_36ho9doMFPJUp2PPv)(nelua_sequence_string__1, int64_t);
struct nelua_sequenceimpl_string__1 {
  nelua_span_string_ data;
  uintptr_t size;
};
typedef struct nlmulret_function_36ho9doMFPJUp2PPv_nelua_sequence_string__1_nlint64 {
  function_36ho9doMFPJUp2PPv r1;
  nelua_sequence_string__1 r2;
  int64_t r3;
} nlmulret_function_36ho9doMFPJUp2PPv_nelua_sequence_string__1_nlint64;
static NELUA_INLINE nlmulret_function_36ho9doMFPJUp2PPv_nelua_sequence_string__1_nlint64 nelua_ipairs_2(nelua_sequence_string__1 a);
static NELUA_INLINE nlmulret_nlboolean_nlint64_nlstring nelua_ipairs_next_1(nelua_sequence_string__1 a_2, int64_t k);
typedef struct nlniltype {} nlniltype;
typedef struct nlniltype nltype;
static NELUA_INLINE void nelua_memory_copy(void* dest, void* src, uintptr_t n);
static NELUA_INLINE void nelua_memory_zero(void* dest, uintptr_t n);
static NELUA_INLINE int32_t nelua_memory_compare(void* a, void* b, uintptr_t n);
static NELUA_INLINE bool nelua_memory_equals(void* a, void* b, uintptr_t n);
static NELUA_INLINE void* nelua_memory_scan(void* src, uint8_t x, uintptr_t n);
static void* nelua_memory_find(void* haystack, uintptr_t haystacksize, void* needle, uintptr_t needlesize);
static NELUA_INLINE void nelua_memory_spanset_1(nelua_span_usize_ dest, uintptr_t x);
static NELUA_INLINE bool nelua_strchar_1_isalpha(uint8_t c);
static NELUA_INLINE bool nelua_strchar_1_islower(uint8_t c);
static NELUA_INLINE bool nelua_strchar_1_isupper(uint8_t c);
static NELUA_INLINE bool nelua_strchar_1_isdigit(uint8_t c);
static NELUA_INLINE bool nelua_strchar_1_isxdigit(uint8_t c);
static NELUA_INLINE bool nelua_strchar_1_iscntrl(uint8_t c);
static NELUA_INLINE bool nelua_strchar_1_isgraph(uint8_t c);
static NELUA_INLINE bool nelua_strchar_1_isspace(uint8_t c);
static NELUA_INLINE bool nelua_strchar_1_isalnum(uint8_t c);
static NELUA_INLINE bool nelua_strchar_1_ispunct(uint8_t c);
static NELUA_INLINE uint8_t nelua_strchar_1_getbasedigit(uint8_t c);
typedef struct nlmulret_nlboolean_nlint64 {
  bool r1;
  int64_t r2;
} nlmulret_nlboolean_nlint64;
static nlmulret_nlboolean_nlint64 nelua_strconv_1_str2int(nlstring s, uint64_t base);
typedef struct NELUA_MAYALIAS nluint8_arr48 {uint8_t v[48];} nluint8_arr48;
typedef union NELUA_MAYALIAS nluint8_arr48_cast {nluint8_arr48 a; uint8_t p[48];} nluint8_arr48_cast;
typedef nluint8_arr48* nluint8_arr48_ptr;
static nlstring nelua_strconv_1_int2str_2(nluint8_arr48_ptr buf, intptr_t x, nlniltype base);
typedef struct NELUA_MAYALIAS nluint8_arr32 {uint8_t v[32];} nluint8_arr32;
typedef union NELUA_MAYALIAS nluint8_arr32_cast {nluint8_arr32 a; uint8_t p[32];} nluint8_arr32_cast;
typedef nluint8_arr32* nluint8_arr32_ptr;
static uintptr_t nelua_scanformat(nluint8_arr0_ptr strfmt, nluint8_arr32_ptr form);
static NELUA_INLINE void nelua_write_stderr(const char* msg, uintptr_t len, bool flush);
static NELUA_NORETURN void nelua_abort(void);
static void nelua_assert_msg_nlvoid(bool cond, nlstring msg);
static void nelua_addlenmod(nluint8_arr32_ptr form, char* lenmod, size_t lenmodsize);
static nelua_GeneralAllocator nelua_general_allocator;
typedef nelua_GeneralAllocator* nelua_GeneralAllocator_ptr;
static NELUA_INLINE void* nelua_GeneralAllocator_alloc_1(nelua_GeneralAllocator_ptr self, uintptr_t size, nlniltype flags);
static NELUA_INLINE void* nelua_GeneralAllocator_alloc0_1(nelua_GeneralAllocator_ptr self, uintptr_t size, nlniltype flags);
static NELUA_INLINE void nelua_GeneralAllocator_dealloc(nelua_GeneralAllocator_ptr self, void* p);
static NELUA_INLINE void* nelua_GeneralAllocator_realloc(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize);
static void* nelua_GeneralAllocator_xalloc_1(nelua_GeneralAllocator_ptr self, uintptr_t size, nlniltype flags);
static NELUA_NORETURN void nelua_panic_string(nlstring s);
static void* nelua_GeneralAllocator_xalloc0_1(nelua_GeneralAllocator_ptr self, uintptr_t size, nlniltype flags);
static void* nelua_GeneralAllocator_realloc0(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize);
static nelua_span_string_ nelua_GeneralAllocator_spanalloc_1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags);
static nelua_span_uint8_ nelua_GeneralAllocator_spanalloc_2(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags);
static nelua_span_limit_pair_ nelua_GeneralAllocator_spanalloc_3(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags);
static nelua_span_cstring_ nelua_GeneralAllocator_spanalloc_4(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags);
static nelua_span_usize_ nelua_GeneralAllocator_spanalloc_5(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags);
static nelua_span_uint8_ nelua_GeneralAllocator_spanalloc0_1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags);
static nelua_span_hashmapnode_string__cint__ nelua_GeneralAllocator_spanalloc0_2(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags);
static void nelua_GeneralAllocator_spandealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_uint8_ s);
static nelua_span_uint8_ nelua_GeneralAllocator_spanrealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_uint8_ s, uintptr_t size);
static nelua_span_string_ nelua_GeneralAllocator_spanrealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_string_ s, uintptr_t size);
static nelua_span_usize_ nelua_GeneralAllocator_spanrealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s, uintptr_t size);
static nelua_span_limit_pair_ nelua_GeneralAllocator_spanrealloc_4(nelua_GeneralAllocator_ptr self, nelua_span_limit_pair_ s, uintptr_t size);
static nelua_span_cstring_ nelua_GeneralAllocator_spanrealloc_5(nelua_GeneralAllocator_ptr self, nelua_span_cstring_ s, uintptr_t size);
static nelua_span_uint8_ nelua_GeneralAllocator_xspanrealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_uint8_ s, uintptr_t size);
static nelua_span_string_ nelua_GeneralAllocator_xspanrealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_string_ s, uintptr_t size);
static nelua_span_usize_ nelua_GeneralAllocator_xspanrealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s, uintptr_t size);
static nelua_span_limit_pair_ nelua_GeneralAllocator_xspanrealloc_4(nelua_GeneralAllocator_ptr self, nelua_span_limit_pair_ s, uintptr_t size);
static nelua_span_cstring_ nelua_GeneralAllocator_xspanrealloc_5(nelua_GeneralAllocator_ptr self, nelua_span_cstring_ s, uintptr_t size);
static nelua_span_uint8_ nelua_GeneralAllocator_spanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_uint8_ s, uintptr_t size);
static nelua_span_hashmapnode_string__cint__ nelua_GeneralAllocator_spanrealloc0_2(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_string__cint__ s, uintptr_t size);
static nelua_span_hashmapnode_string__cint__ nelua_GeneralAllocator_xspanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_string__cint__ s, uintptr_t size);
static nelua_sequenceimpl_string__1_ptr nelua_GeneralAllocator_new_3(nelua_GeneralAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags);
static nelua_sequenceimpl_limit_pair__ptr nelua_GeneralAllocator_new_4(nelua_GeneralAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags);
typedef struct nelua_sequenceimpl_cstring_ nelua_sequenceimpl_cstring_;
typedef nelua_sequenceimpl_cstring_* nelua_sequenceimpl_cstring__ptr;
struct nelua_sequenceimpl_cstring_ {
  nelua_span_cstring_ data;
  uintptr_t size;
};
static nelua_sequenceimpl_cstring__ptr nelua_GeneralAllocator_new_5(nelua_GeneralAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags);
typedef struct nelua_stringbuilderT nelua_stringbuilderT;
typedef nelua_stringbuilderT* nelua_stringbuilderT_ptr;
struct nelua_stringbuilderT {
  nelua_span_uint8_ data;
  uintptr_t size;
  nelua_GeneralAllocator allocator;
};
static void nelua_stringbuilderT_destroy(nelua_stringbuilderT_ptr self);
static bool nelua_stringbuilderT_grow(nelua_stringbuilderT_ptr self, uintptr_t newsize);
static nelua_span_uint8_ nelua_stringbuilderT_prepare(nelua_stringbuilderT_ptr self, uintptr_t n);
static void nelua_stringbuilderT_commit(nelua_stringbuilderT_ptr self, uintptr_t n);
static bool nelua_stringbuilderT_writebyte_1(nelua_stringbuilderT_ptr self, uint8_t c, nlniltype n);
typedef struct nlmulret_nlboolean_nlusize {
  bool r1;
  uintptr_t r2;
} nlmulret_nlboolean_nlusize;
static nlmulret_nlboolean_nlusize nelua_stringbuilderT_write_1(nelua_stringbuilderT_ptr self, nlstring __arg1);
typedef struct nlmulret_nlboolean_nlisize {
  bool r1;
  intptr_t r2;
} nlmulret_nlboolean_nlisize;
static nlmulret_nlboolean_nlisize nelua_formatarg_2(nelua_stringbuilderT_ptr self, uint8_t c, nluint8_arr32_ptr form, int arg1);
static nlmulret_nlboolean_nlisize nelua_formatarg_3(nelua_stringbuilderT_ptr self, uint8_t c, nluint8_arr32_ptr form, int64_t arg1);
static nlmulret_nlboolean_nlisize nelua_formatarg_4(nelua_stringbuilderT_ptr self, uint8_t c, nluint8_arr32_ptr form, nlstring arg1);
static nlmulret_nlboolean_nlusize nelua_stringbuilderT_writef_2(nelua_stringbuilderT_ptr self, nlstring fmt, int __arg1);
static nlmulret_nlboolean_nlusize nelua_stringbuilderT_writef_3(nelua_stringbuilderT_ptr self, nlstring fmt, int64_t __arg1, int64_t __arg2);
static nlmulret_nlboolean_nlusize nelua_stringbuilderT_writef_4(nelua_stringbuilderT_ptr self, nlstring fmt, nlstring __arg1, int __arg2, int64_t __arg3, int64_t __arg4);
static nlmulret_nlboolean_nlusize nelua_stringbuilderT_writef_5(nelua_stringbuilderT_ptr self, nlstring fmt);
static nlmulret_nlboolean_nlusize nelua_stringbuilderT_writef_6(nelua_stringbuilderT_ptr self, nlstring fmt, nlstring __arg1, nlstring __arg2);
static nlmulret_nlboolean_nlusize nelua_stringbuilderT_writef_7(nelua_stringbuilderT_ptr self, nlstring fmt, int __arg1, nlstring __arg2, nlstring __arg3);
static nlmulret_nlboolean_nlusize nelua_stringbuilderT_writef_8(nelua_stringbuilderT_ptr self, nlstring fmt, nlstring __arg1);
static nlmulret_nlboolean_nlusize nelua_stringbuilderT_writef_9(nelua_stringbuilderT_ptr self, nlstring fmt, nlstring __arg1, nlstring __arg2, nlstring __arg3);
static nlmulret_nlboolean_nlusize nelua_stringbuilderT_writef_10(nelua_stringbuilderT_ptr self, nlstring fmt, nlstring __arg1, int64_t __arg2);
static nlstring nelua_stringbuilderT_view(nelua_stringbuilderT_ptr self);
static nlstring nelua_stringbuilderT_promote(nelua_stringbuilderT_ptr self);
typedef nelua_sequence_string__1* nelua_sequence_string__1_ptr;
static void nelua_sequence_string__1__init(nelua_sequence_string__1_ptr self);
static void nelua_sequence_string__1_reserve(nelua_sequence_string__1_ptr self, uintptr_t n);
static NELUA_NOINLINE void nelua_sequenceT_grow_1(nelua_sequence_string__1_ptr self);
static NELUA_INLINE nlstring_ptr nelua_sequence_string__1___atindex(nelua_sequence_string__1_ptr self, uintptr_t pos);
static NELUA_INLINE intptr_t nelua_sequence_string__1___len(nelua_sequence_string__1_ptr self);
typedef nelua_sequence_limit_pair_* nelua_sequence_limit_pair__ptr;
static void nelua_sequence_limit_pair___init(nelua_sequence_limit_pair__ptr self);
static NELUA_NOINLINE void nelua_sequenceT_grow_2(nelua_sequence_limit_pair__ptr self);
static NELUA_INLINE void nelua_sequence_limit_pair__push(nelua_sequence_limit_pair__ptr self, bwrapbox_limit_pair v);
static NELUA_INLINE bwrapbox_limit_pair_ptr nelua_sequence_limit_pair____atindex(nelua_sequence_limit_pair__ptr self, uintptr_t pos);
static NELUA_INLINE intptr_t nelua_sequence_limit_pair____len(nelua_sequence_limit_pair__ptr self);
typedef struct nelua_sequence_cstring_ nelua_sequence_cstring_;
typedef nelua_sequence_cstring_* nelua_sequence_cstring__ptr;
struct nelua_sequence_cstring_ {
  nelua_sequenceimpl_cstring__ptr impl;
  nelua_GeneralAllocator allocator;
};
static void nelua_sequence_cstring___init(nelua_sequence_cstring__ptr self);
static NELUA_NOINLINE void nelua_sequenceT_grow_3(nelua_sequence_cstring__ptr self);
static NELUA_INLINE void nelua_sequence_cstring__push(nelua_sequence_cstring__ptr self, char* v);
static NELUA_INLINE nlcstring_ptr nelua_sequence_cstring____atindex(nelua_sequence_cstring__ptr self, uintptr_t pos);
static nlstring nelua_nlstring_create(uintptr_t size);
static void nelua_nlstring_destroy(nlstring_ptr self);
static nlstring nelua_nlstring_copy(nlstring s);
static nlstring nelua_nlstring_subview_1(nlstring s, intptr_t i, intptr_t j);
static nlstring nelua_nlstring_format_2(nlstring fmt, int __arg1);
static nlstring nelua_nlstring_concat_1(nelua_span_string_ list, nlniltype sep);
static void nelua_nlstring___close(nlstring_ptr self);
static NELUA_INLINE nluint8_ptr nelua_nlstring___atindex(nlstring s, uintptr_t i);
static NELUA_INLINE intptr_t nelua_nlstring___len(nlstring a);
static nlstring nelua_nlstring___concat_2(nlstring a, nlstring b);
static bool nelua_nlstring___eq(nlstring a, nlstring b);
typedef struct nelua_StrPattCapture nelua_StrPattCapture;
typedef nelua_StrPattCapture* nelua_StrPattCapture_ptr;
struct nelua_StrPattCapture {
  intptr_t init;
  intptr_t len;
};
static bool nelua_StrPattCapture_is_unfinished(nelua_StrPattCapture_ptr self);
static bool nelua_StrPattCapture_is_position(nelua_StrPattCapture_ptr self);
static bool nelua_match_has_pattern_specials(nlstring pattern);
static bool nelua_match_has_pattern_anchor(nlstring pattern);
typedef struct nelua_StrPatt_1 nelua_StrPatt_1;
struct nelua_StrPatt_1 {
  nlstring source;
  nlstring pattern;
  intptr_t depth;
  intptr_t numcaptures;
  nelua_StrPattCapture capture[32];
  bool plain;
  bool anchor;
};
static nelua_StrPatt_1 nelua_StrPatt_1_create(nlstring source, nlstring pattern, bool plain);
typedef nelua_StrPatt_1* nelua_StrPatt_1_ptr;
static void nelua_StrPatt_1_reset_captures(nelua_StrPatt_1_ptr self);
typedef struct nlmulret_nlboolean_nlstring_nelua_StrPattCapture {
  bool r1;
  nlstring r2;
  nelua_StrPattCapture r3;
} nlmulret_nlboolean_nlstring_nelua_StrPattCapture;
static nlmulret_nlboolean_nlstring_nelua_StrPattCapture nelua_StrPatt_1_get_capture(nelua_StrPatt_1_ptr self, intptr_t i);
static intptr_t nelua_StrPatt_1__match(nelua_StrPatt_1_ptr ms, intptr_t s, intptr_t p);
static bool nelua_match_class(uint8_t c, uint8_t cl);
static intptr_t nelua_match_class_end(nelua_StrPatt_1_ptr ms_1, intptr_t p_1);
static bool nelua_match_bracket_class(nelua_StrPatt_1_ptr ms_2, uint8_t c, intptr_t p_2, intptr_t ep);
static bool nelua_match_single(nelua_StrPatt_1_ptr ms_3, intptr_t s_1, intptr_t p_3, intptr_t ep);
static intptr_t nelua_match_balance(nelua_StrPatt_1_ptr ms_4, intptr_t s_2, intptr_t p_4);
static intptr_t nelua_match_max_expand(nelua_StrPatt_1_ptr ms_5, intptr_t s_3, intptr_t p_5, intptr_t ep);
static intptr_t nelua_match_min_expand(nelua_StrPatt_1_ptr ms_6, intptr_t s_4, intptr_t p_6, intptr_t ep);
static intptr_t nelua_match_start_capture(nelua_StrPatt_1_ptr ms_7, intptr_t s_5, intptr_t p_7, intptr_t what);
static intptr_t nelua_match_end_capture(nelua_StrPatt_1_ptr ms_8, intptr_t s_6, intptr_t p_8);
static intptr_t nelua_match_capture(nelua_StrPatt_1_ptr ms_9, intptr_t s_7, intptr_t l);
typedef struct nlmulret_nlisize_nlisize {
  intptr_t r1;
  intptr_t r2;
} nlmulret_nlisize_nlisize;
static nlmulret_nlisize_nlisize nelua_StrPatt_1_match(nelua_StrPatt_1_ptr ms, intptr_t s);
static nlmulret_nlisize_nlisize nelua_nlstring_find_1(nlstring s, nlstring pattern, intptr_t init, bool plain);
typedef struct nlmulret_nlstring_nlisize {
  nlstring r1;
  intptr_t r2;
} nlmulret_nlstring_nlisize;
static nlmulret_nlstring_nlisize nelua_nlstring_gsub_1(nlstring s, nlstring pattern, nlstring repl, nlniltype maxn);
static NELUA_INLINE bool nelua_lt_nlisize_nlusize(intptr_t a, uintptr_t b);
static nlstring nelua_tostring_3(intptr_t x);
static nlstring nelua_tostring_4(int64_t x);
static nlstring nelua_tostring_5(int x);
static int64_t nelua_tointeger_1(nlstring x, nlniltype base);
typedef FILE* FILE_ptr;
typedef struct nelua_filestream nelua_filestream;
typedef nelua_filestream* nelua_filestream_ptr;
typedef struct nelua_FStream nelua_FStream;
typedef nelua_FStream* nelua_FStream_ptr;
struct nelua_filestream {
  nelua_FStream_ptr fs;
};
typedef int (*function_5Wd6wjFfRjpE5ak72)(FILE_ptr);
struct nelua_FStream {
  FILE_ptr fp;
  function_5Wd6wjFfRjpE5ak72 closef;
};
static NELUA_INLINE FILE_ptr nelua_filestream__getfp(nelua_filestream_ptr self);
typedef struct nlmulret_nlstring_nlint64 {
  nlstring r1;
  int64_t r2;
} nlmulret_nlstring_nlint64;
static nlmulret_nlstring_nlint64 nelua_geterrno(void);
static NELUA_INLINE nlstring nelua_cstring2string(const char* s);
typedef struct nlmulret_nlboolean_nlstring_nlint64 {
  bool r1;
  nlstring r2;
  int64_t r3;
} nlmulret_nlboolean_nlstring_nlint64;
static nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_flush(nelua_filestream_ptr self);
static nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_write_1(nelua_filestream_ptr self, nlstring __arg1);
static nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_writef_1(nelua_filestream_ptr self, nlstring fmt, int64_t __arg1, int64_t __arg2);
static nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_writef_2(nelua_filestream_ptr self, nlstring fmt, nlstring __arg1, int __arg2, int64_t __arg3, int64_t __arg4);
static nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_writef_3(nelua_filestream_ptr self, nlstring fmt);
static nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_writef_4(nelua_filestream_ptr self, nlstring fmt, int __arg1);
static nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_writef_5(nelua_filestream_ptr self, nlstring fmt, nlstring __arg1, nlstring __arg2);
static nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_writef_6(nelua_filestream_ptr self, nlstring fmt, int __arg1, nlstring __arg2, nlstring __arg3);
static nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_writef_7(nelua_filestream_ptr self, nlstring fmt, nlstring __arg1);
static nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_writef_8(nelua_filestream_ptr self, nlstring fmt, nlstring __arg1, nlstring __arg2, nlstring __arg3);
static nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_writef_9(nelua_filestream_ptr self, nlstring fmt, nlstring __arg1, int64_t __arg2);
static void nelua_filestream_printf_1(nelua_filestream_ptr self, nlstring __arg1, int64_t __arg2, int64_t __arg3);
static void nelua_filestream_printf_2(nelua_filestream_ptr self, nlstring __arg1, nlstring __arg2, int __arg3, int64_t __arg4, int64_t __arg5);
static nelua_FStream nelua_stdoutfs;
static nelua_filestream nelua_io_stdout;
static nelua_FStream nelua_stderrfs;
static nelua_filestream nelua_io_stderr;
static nltype nelua_require_io(nlniltype modname);
static double nelua_os_now(void);
static NELUA_INLINE int64_t nelua_math_min_1(int64_t __arg1, int64_t __arg2);
static NELUA_INLINE int64_t nelua_math_max_1(int64_t __arg1, int64_t __arg2);
static nelua_sequence_string__1 nelua_arg;
static int nelua_argc;
static nlcstring_arr0_ptr nelua_argv;
static nelua_sequence_string__1 nelua_require_arg(nlniltype modname);
static NELUA_INLINE uintptr_t nelua_lhash(nluint8_arr0_ptr data, uintptr_t len, uintptr_t seed, uintptr_t step);
static NELUA_INLINE uintptr_t nelua_hash_long(nelua_span_uint8_ data);
static uintptr_t nelua_hash_hash_1(nlstring v);
static NELUA_INLINE uintptr_t nelua_ceilidiv(uintptr_t x, uintptr_t y);
static NELUA_INLINE uintptr_t nelua_hashmod(uintptr_t h, uintptr_t n);
static NELUA_INLINE uintptr_t nelua_roundpow2(uintptr_t n);
typedef struct nlmulret_nlusize_nlusize_nlusize {
  uintptr_t r1;
  uintptr_t r2;
  uintptr_t r3;
} nlmulret_nlusize_nlusize_nlusize;
typedef struct nelua_hashmap_string__cint_ nelua_hashmap_string__cint_;
typedef nelua_hashmap_string__cint_* nelua_hashmap_string__cint__ptr;
struct nelua_hashmap_string__cint_ {
  nelua_span_usize_ buckets;
  nelua_span_hashmapnode_string__cint__ nodes;
  uintptr_t size;
  uintptr_t free_index;
  nelua_GeneralAllocator allocator;
};
static NELUA_INLINE nlmulret_nlusize_nlusize_nlusize nelua_hashmap_string__cint___find(nelua_hashmap_string__cint__ptr self, nlstring key);
static NELUA_NOINLINE void nelua_hashmap_string__cint__rehash(nelua_hashmap_string__cint__ptr self, uintptr_t bucket_count);
static uintptr_t nelua_hashmap_string__cint___at(nelua_hashmap_string__cint__ptr self, nlstring key);
typedef int* nlcint_ptr;
static nlcint_ptr nelua_hashmap_string__cint____atindex(nelua_hashmap_string__cint__ptr self, nlstring key);
static nlcint_ptr nelua_hashmap_string__cint__peek(nelua_hashmap_string__cint__ptr self, nlstring key);
static bool nelua_hashmap_string__cint__has(nelua_hashmap_string__cint__ptr self, nlstring key);
static nelua_hashmap_string__cint_ bwrapbox_rlimit_map;
static bool bwrapbox_is_child = false;
static void bwrapbox_fail_1(nlstring msg);
static void bwrapbox_fail_2(nlstring msg, int __arg1);
static void bwrapbox_fail_3(nlstring msg, nlstring __arg1, nlstring __arg2);
static void bwrapbox_fail_4(nlstring msg, int __arg1, nlstring __arg2, nlstring __arg3);
static void bwrapbox_fail_5(nlstring msg, nlstring __arg1);
static void bwrapbox_fail_6(nlstring msg, nlstring __arg1, nlstring __arg2, nlstring __arg3);
static void bwrapbox_fail_7(nlstring msg, nlstring __arg1, int64_t __arg2);
static void bwrapbox_usleep(int64_t usecs);
typedef struct timespec timespec_t;
static NELUA_NORETURN void nelua_panic_cstring(const char* s);
static NELUA_INLINE int64_t nelua_idiv_nlint64(int64_t a, int64_t b);
static NELUA_INLINE int64_t nelua_imod_nlint64(int64_t a, int64_t b);
typedef timespec_t* timespec_t_ptr;
typedef struct nlmulret_nlcint_nlstring {
  int r1;
  nlstring r2;
} nlmulret_nlcint_nlstring;
static nlmulret_nlcint_nlstring bwrapbox_wait_child_pid(int pid);
static bool bwrapbox_isdir(nlstring path);
typedef struct stat stat_t;
static NELUA_INLINE char* nelua_string2cstring(nlstring s);
static nlmulret_nlboolean_nlstring_nlint64 bwrapbox_result_from_errno(bool ok);
static nlmulret_nlboolean_nlstring_nlint64 bwrapbox_fs_mkdir(nlstring path);
static nlmulret_nlboolean_nlstring_nlint64 bwrapbox_fs_rmdir(nlstring path);
static nlmulret_nlboolean_nlstring_nlint64 bwrapbox_fs_mkfile(nlstring path, nlstring contents);
typedef struct nlmulret_nlstring_nlstring_nlint64 {
  nlstring r1;
  nlstring r2;
  int64_t r3;
} nlmulret_nlstring_nlstring_nlint64;
static nlmulret_nlstring_nlstring_nlint64 bwrapbox_fs_readfile(nlstring path);
static void bwrapbox_cgroup_create(nlstring cgroup_path);
static void bwrapbox_cgroup_kill_and_destroy(nlstring cgroup_path);
static void bwrapbox_cgroup_set_limits(nlstring cgroup_path, nelua_sequence_limit_pair_ limits);
static void bwrapbox_cgroup_migrate_pid(nlstring cgroup_path, int pid);
static int64_t bwrapbox_cgroup_cputime_usecs(nlstring cgroup_path);
static bool bwrapbox_cgroup_enabled;
static bool bwrapbox_cgroup_overwrite;
static nlstring bwrapbox_cgroup_path;
static nelua_sequence_limit_pair_ bwrapbox_cgroup_limits;
static int64_t bwrapbox_cgroup_high_usecs = -1;
static int64_t bwrapbox_cgroup_max_usecs = -1;
static int64_t bwrapbox_elapsed_high_limit_usecs = -1;
static int64_t bwrapbox_elapsed_max_limit_usecs = -1;
static bool bwrapbox_quiet;
static uint32_t bwrapbox_exec_uid = 0xffffffffULL;
static uint32_t bwrapbox_exec_gid = 0xffffffffULL;
static nelua_sequence_limit_pair_ bwrapbox_exec_limits;
static void bwrapbox_print_help(nlstring arg0);
static char nelua_strlit_1[756] = " [OPTIONS...] [--] COMMAND [ARGS...]\n\n    --help                       Print this help\n    --cgroup NAME                The cgroup name to run\n    --cgroup-overwrite           Kill and destroy cgroup in case it already exists\n    --climit VAR VALUE           Set cgroup limit (sum of all processes in cgroup)\n    --rlimit VAR VALUE           Set resource limit (per process)\n    --climit-elapsed-high VALUE  Elapsed time limit before raising signal SIGXCPU (in microseconds)\n    --climit-elapsed-max VALUE   Elapsed time limit before raising signal SIGKILL (in microseconds)\n    --setuid VALUE               Set UID before running bwrap\n    --setgid VALUE               Set GID before running bwrap\n    --quiet                      Suppress exit message\n\n";
static nelua_sequence_cstring_ bwrapbox_parse_args(void);
static void bwrapbox_set_rlimits(nelua_sequence_limit_pair_ limits);
typedef struct rlimit rlimit_t;
static NELUA_NORETURN void bwrapbox_bwrap_exec(nelua_sequence_cstring_ args, nelua_sequence_limit_pair_ rlimits, uint32_t uid, uint32_t gid);
static void bwrapbox_cgroup_wait_time_and_kill(nlstring cgroup_path_1, int64_t cpu_max_usecs, int64_t time_max_usecs, int pid, int sig);
static void bwrapbox_after_fork(void);
static int bwrapbox_fork_cgroup_time_limiter(nlstring cgroup_path_2, int64_t cpu_high_usecs, int64_t cpu_max_usecs, int64_t time_high_usecs, int64_t time_max_usecs, int kill_pid);
static int bwrapbox_fork_cgroup_bwrap_exec(nlstring cgroup_path_3, nelua_sequence_cstring_ args, nelua_sequence_limit_pair_ rlimits, uint32_t uid, uint32_t gid);
static void bwrapbox_cleanup_cgroup(void);
static void bwrapbox_signal_handler(int signum);
static nelua_sequence_cstring_ bwrapbox_bwrap_args;
typedef struct sigaction sigaction_t;
typedef sigaction_t* sigaction_t_ptr;
static int nelua_main(int argc, char** argv);
/* ------------------------------ DEFINITIONS ------------------------------- */
bool nelua_span_uint8__empty(nelua_span_uint8_ self) {
  return (self.size == 0);
}
nluint8_ptr nelua_span_uint8____atindex(nelua_span_uint8_ self, uintptr_t i) {
  return (&self.data[i]);
}
nlstring_ptr nelua_span_string____atindex(nelua_span_string_ self, uintptr_t i) {
  return (&self.data[i]);
}
nelua_span_string_ nelua_span_string____convert_1(nlstring_arr3_ptr values) {
  nelua_span_string_ self = (nelua_span_string_){0};
  if(true) {
    self.data = ((nlstring_arr0_ptr)(&values->v[0]));
    self.size = 3U;
  }
  return self;
}
nlusize_ptr nelua_span_usize____atindex(nelua_span_usize_ self, uintptr_t i) {
  return (&self.data[i]);
}
nelua_hashmapnode_string__cint__ptr nelua_span_hashmapnode_string__cint_____atindex(nelua_span_hashmapnode_string__cint__ self, uintptr_t i) {
  return (&self.data[i]);
}
bwrapbox_limit_pair_ptr nelua_span_limit_pair____atindex(nelua_span_limit_pair_ self, uintptr_t i) {
  return (&self.data[i]);
}
nlcstring_ptr nelua_span_cstring____atindex(nelua_span_cstring_ self, uintptr_t i) {
  return (&self.data[i]);
}
nlmulret_nlboolean_nlint64_bwrapbox_limit_pair nelua_ipairs_next(nelua_sequence_limit_pair_ a_1, int64_t k) {
  k = (k + 1);
  if((k >= (nelua_sequence_limit_pair____len((&a_1)) + 1))) {
    return (nlmulret_nlboolean_nlint64_bwrapbox_limit_pair){false, 0, (bwrapbox_limit_pair){0}};
  }
  nlmulret_nlboolean_nlint64_bwrapbox_limit_pair _mulret_1;
  _mulret_1.r1 = true;
  _mulret_1.r2 = k;
  _mulret_1.r3 = (*nelua_sequence_limit_pair____atindex((&a_1), (uintptr_t)k));
  return _mulret_1;
}
nlmulret_function_3cvqKRRWFe2qk8ZgD_nelua_sequence_limit_pair__nlint64 nelua_ipairs_1(nelua_sequence_limit_pair_ a) {
  return (nlmulret_function_3cvqKRRWFe2qk8ZgD_nelua_sequence_limit_pair__nlint64){nelua_ipairs_next, a, 0};
}
nlmulret_nlboolean_nlint64_nlstring nelua_ipairs_next_1(nelua_sequence_string__1 a_2, int64_t k) {
  k = (k + 1);
  if((k >= (nelua_sequence_string__1___len((&a_2)) + 1))) {
    return (nlmulret_nlboolean_nlint64_nlstring){false, 0, (nlstring){0}};
  }
  nlmulret_nlboolean_nlint64_nlstring _mulret_1;
  _mulret_1.r1 = true;
  _mulret_1.r2 = k;
  _mulret_1.r3 = (*nelua_sequence_string__1___atindex((&a_2), (uintptr_t)k));
  return _mulret_1;
}
nlmulret_function_36ho9doMFPJUp2PPv_nelua_sequence_string__1_nlint64 nelua_ipairs_2(nelua_sequence_string__1 a) {
  return (nlmulret_function_36ho9doMFPJUp2PPv_nelua_sequence_string__1_nlint64){nelua_ipairs_next_1, a, 0};
}
void nelua_memory_copy(void* dest, void* src, uintptr_t n) {
  if(NELUA_UNLIKELY((n == 0))) {
    return;
  }
  memcpy(dest, src, (size_t)n);
}
void nelua_memory_zero(void* dest, uintptr_t n) {
  if(NELUA_UNLIKELY((n == 0))) {
    return;
  }
  memset(dest, 0, (size_t)n);
}
int32_t nelua_memory_compare(void* a, void* b, uintptr_t n) {
  if(NELUA_UNLIKELY((n == 0))) {
    return 0;
  }
  return (int32_t)memcmp(a, b, (size_t)n);
}
bool nelua_memory_equals(void* a, void* b, uintptr_t n) {
  if(NELUA_UNLIKELY((n == 0))) {
    return true;
  }
  return (memcmp(a, b, (size_t)n) == 0);
}
void* nelua_memory_scan(void* src, uint8_t x, uintptr_t n) {
  if(NELUA_UNLIKELY((n == 0))) {
    return (void*)NULL;
  }
  return memchr(src, (int)x, (size_t)n);
}
void* nelua_memory_find(void* haystack, uintptr_t haystacksize, void* needle, uintptr_t needlesize) {
  if(NELUA_UNLIKELY(((needlesize == 0) || (haystack == needle)))) {
    return haystack;
  } else if(NELUA_UNLIKELY((needlesize > haystacksize))) {
    return (void*)NULL;
  } else {
    if((needlesize == 1)) {
      return memchr(haystack, (int)(*(nluint8_ptr)needle), (size_t)haystacksize);
    }
    uintptr_t haystackbegin = (uintptr_t)haystack;
    for(uintptr_t i = haystackbegin, _end = (haystackbegin + (haystacksize - needlesize)); i <= _end; i += 1) {
      void* p = (void*)i;
      if((memcmp(p, needle, (size_t)needlesize) == 0)) {
        return p;
      }
    }
    return (void*)NULL;
  }
}
void nelua_memory_spanset_1(nelua_span_usize_ dest, uintptr_t x) {
  for(uintptr_t i = 0U, _end = dest.size; i < _end; i += 1) {
    (*nelua_span_usize____atindex(dest, i)) = x;
  }
}
bool nelua_strchar_1_isalpha(uint8_t c) {
  return ((((uint32_t)c | 32) - 97U) < 26);
}
bool nelua_strchar_1_islower(uint8_t c) {
  return (((uint32_t)c - 97U) < 26);
}
bool nelua_strchar_1_isupper(uint8_t c) {
  return (((uint32_t)c - 65U) < 26);
}
bool nelua_strchar_1_isdigit(uint8_t c) {
  return (((uint32_t)c - 48U) < 10);
}
bool nelua_strchar_1_isxdigit(uint8_t c) {
  return (nelua_strchar_1_isdigit(c) || ((((uint32_t)c | 32) - 97U) < 6));
}
bool nelua_strchar_1_iscntrl(uint8_t c) {
  return (((uint32_t)c < 0x20) || (c == 0x7f));
}
bool nelua_strchar_1_isgraph(uint8_t c) {
  return (((uint32_t)c - 0x21) < 0x5e);
}
bool nelua_strchar_1_isspace(uint8_t c) {
  return ((c == 32U) || (((uint32_t)c - 9U) < 5));
}
bool nelua_strchar_1_isalnum(uint8_t c) {
  return (nelua_strchar_1_isalpha(c) || nelua_strchar_1_isdigit(c));
}
bool nelua_strchar_1_ispunct(uint8_t c) {
  return (nelua_strchar_1_isgraph(c) && (!nelua_strchar_1_isalnum(c)));
}
uint8_t nelua_strchar_1_getbasedigit(uint8_t c) {
  uint8_t d = (c - 48U);
  if((d < 10)) {
    return d;
  }
  d = (c - 97U);
  if((d < 26)) {
    return (d + 10);
  }
  d = (c - 65U);
  if((d < 26)) {
    return (d + 10);
  }
  return 255U;
}
nlmulret_nlboolean_nlint64 nelua_strconv_1_str2int(nlstring s, uint64_t base) {
  if((s.size == 0)) {
    return (nlmulret_nlboolean_nlint64){false, 0};
  }
  uintptr_t pos = 0U;
  while(((pos < s.size) && nelua_strchar_1_isspace(s.data[pos]))) {
    pos = (pos + 1);
  }
  if((pos >= s.size)) {
    return (nlmulret_nlboolean_nlint64){false, 0};
  }
  bool neg = false;
  if((s.data[pos] == 45U)) {
    pos = (pos + 1);
    neg = true;
  } else if((s.data[pos] == 43U)) {
    pos = (pos + 1);
  }
  if((base == 0)) {
    base = 10U;
    if(((s.data[pos] == 48U) && ((pos + 1) < s.size))) {
      uint8_t bc = s.data[(pos + 1)];
      if(((bc == 98U) || (bc == 66U))) {
        base = 2U;
        pos = (pos + 2);
      } else if(((bc == 120U) || (bc == 88U))) {
        base = 16U;
        pos = (pos + 2);
      }
    }
  }
  if((!((base >= 2) && (base <= 36)))) {
    return (nlmulret_nlboolean_nlint64){false, 0};
  }
  uint64_t n = 0U;
  while((pos < s.size)) {
    uint64_t x = (uint64_t)nelua_strchar_1_getbasedigit(s.data[pos]);
    if((x >= base)) {
      break;
    }
    n = ((n * base) + x);
    pos = (pos + 1);
  }
  while(((pos < s.size) && nelua_strchar_1_isspace(s.data[pos]))) {
    pos = (pos + 1);
  }
  if((pos != s.size)) {
    return (nlmulret_nlboolean_nlint64){false, 0};
  }
  if(neg) {
    n = (-n);
  }
  return (nlmulret_nlboolean_nlint64){true, (int64_t)n};
}
nlstring nelua_strconv_1_int2str_2(nluint8_arr48_ptr buf, intptr_t x, nlniltype base) {
  uintptr_t pos = 47U;
  buf->v[pos] = 0U;
  pos = (pos - 1);
  bool neg = (x < 0);
  if((x == 0)) {
    buf->v[pos] = 48U;
    pos = (pos - 1);
  } else {
    while((x != 0)) {
      intptr_t quot = (x / 10);
      intptr_t rema = (x - (quot * 10));
      if((rema < 0)) {
        rema = (-rema);
      }
      x = quot;
      buf->v[pos] = (uint8_t)(rema + 48);
      pos = (pos - 1);
    }
  }
  if(neg) {
    buf->v[pos] = 45U;
    pos = (pos - 1);
  }
  return (nlstring){.data = ((nluint8_arr0_ptr)(&buf->v[(pos + 1)])), .size = ((48 - pos) - 2)};
}
void nelua_write_stderr(const char* msg, uintptr_t len, bool flush) {
  if(len > 0 && msg) {
    fwrite(msg, 1, len, stderr);
  }
  if(flush) {
    fwrite("\n", 1, 1, stderr);
    fflush(stderr);
  }
}
void nelua_abort(void) {
  NELUA_UBSAN_UNREACHABLE();
  abort();
}
void nelua_assert_msg_nlvoid(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr((const char*)msg.data, msg.size, true);
    nelua_abort();
  }
}
uintptr_t nelua_scanformat(nluint8_arr0_ptr strfmt, nluint8_arr32_ptr form) {
  uintptr_t p = 0U;
  while(((strfmt[p] != 0) && (nelua_memory_scan((void*)((nlstring){(uint8_t*)"-+ #0", 5}).data, strfmt[p], 5U) != (void*)NULL))) {
    p = (p + 1);
  }
  nelua_assert_msg_nlvoid((p < (((nlstring){(uint8_t*)"-+ #0", 5}).size + 1)), ((nlstring){(uint8_t*)"invalid format (repeated flags)", 31}));
  if(nelua_strchar_1_isdigit(strfmt[p])) {
    p = (p + 1);
  }
  if(nelua_strchar_1_isdigit(strfmt[p])) {
    p = (p + 1);
  }
  if((strfmt[p] == 46U)) {
    p = (p + 1);
    if(nelua_strchar_1_isdigit(strfmt[p])) {
      p = (p + 1);
    }
    if(nelua_strchar_1_isdigit(strfmt[p])) {
      p = (p + 1);
    }
  }
  nelua_assert_msg_nlvoid((!nelua_strchar_1_isdigit(strfmt[p])), ((nlstring){(uint8_t*)"invalid format (width or precision too long)", 44}));
  form->v[0] = 37U;
  nelua_memory_copy((void*)(&form->v[1]), (void*)(&strfmt[0]), (p + 1));
  form->v[(p + 2)] = 0U;
  return p;
}
void nelua_addlenmod(nluint8_arr32_ptr form, char* lenmod, size_t lenmodsize) {
  size_t l = (size_t)((intptr_t)strlen((char*)(&form->v[0])));
  uint8_t spec = form->v[(l - 1)];
  nelua_memory_copy((void*)(&form->v[(l - 1)]), (void*)lenmod, (uintptr_t)lenmodsize);
  form->v[((l + lenmodsize) - 1)] = spec;
  form->v[(l + lenmodsize)] = 0U;
}
void* nelua_GeneralAllocator_alloc_1(nelua_GeneralAllocator_ptr self, uintptr_t size, nlniltype flags) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  return malloc((size_t)size);
}
void* nelua_GeneralAllocator_alloc0_1(nelua_GeneralAllocator_ptr self, uintptr_t size, nlniltype flags) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  return calloc((size_t)size, 1U);
}
void nelua_GeneralAllocator_dealloc(nelua_GeneralAllocator_ptr self, void* p) {
  if(NELUA_UNLIKELY((p == (void*)NULL))) {
    return;
  }
  free(p);
}
void* nelua_GeneralAllocator_realloc(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize) {
  if(NELUA_UNLIKELY((newsize == 0))) {
    if(NELUA_LIKELY((p != (void*)NULL))) {
      free(p);
    }
    return (void*)NULL;
  } else if(NELUA_UNLIKELY((newsize == oldsize))) {
    return p;
  }
  return realloc(p, (size_t)newsize);
}
void nelua_panic_string(nlstring s) {
  if(s.size > 0) {
    nelua_write_stderr((const char*)s.data, s.size, true);
  }
  nelua_abort();
}
void* nelua_GeneralAllocator_xalloc_1(nelua_GeneralAllocator_ptr self, uintptr_t size, nlniltype flags) {
  void* p = nelua_GeneralAllocator_alloc_1(self, size, NELUA_NIL);
  if(NELUA_UNLIKELY(((p == (void*)NULL) && (size > 0)))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return p;
}
void* nelua_GeneralAllocator_xalloc0_1(nelua_GeneralAllocator_ptr self, uintptr_t size, nlniltype flags) {
  void* p = nelua_GeneralAllocator_alloc0_1(self, size, NELUA_NIL);
  if(NELUA_UNLIKELY(((p == (void*)NULL) && (size > 0)))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return p;
}
void* nelua_GeneralAllocator_realloc0(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize) {
  p = nelua_GeneralAllocator_realloc(self, p, newsize, oldsize);
  if(NELUA_LIKELY(((newsize > oldsize) && (p != (void*)NULL)))) {
    nelua_memory_zero((void*)(&((nluint8_arr0_ptr)p)[oldsize]), (newsize - oldsize));
  }
  return p;
}
nelua_span_string_ nelua_GeneralAllocator_spanalloc_1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags) {
  if(NELUA_LIKELY((size > 0))) {
    nlstring_arr0_ptr data = ((nlstring_arr0_ptr)nelua_GeneralAllocator_alloc_1(self, (size * 16), NELUA_NIL));
    if(NELUA_LIKELY((data != ((nlstring_arr0_ptr)NULL)))) {
      return (nelua_span_string_){.data = data, .size = size};
    }
  }
  return (nelua_span_string_){0};
}
nelua_span_uint8_ nelua_GeneralAllocator_spanalloc_2(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags) {
  if(NELUA_LIKELY((size > 0))) {
    nluint8_arr0_ptr data = ((nluint8_arr0_ptr)nelua_GeneralAllocator_alloc_1(self, (size * 1), NELUA_NIL));
    if(NELUA_LIKELY((data != ((nluint8_arr0_ptr)NULL)))) {
      return (nelua_span_uint8_){.data = data, .size = size};
    }
  }
  return (nelua_span_uint8_){0};
}
nelua_span_limit_pair_ nelua_GeneralAllocator_spanalloc_3(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags) {
  if(NELUA_LIKELY((size > 0))) {
    bwrapbox_limit_pair_arr0_ptr data = ((bwrapbox_limit_pair_arr0_ptr)nelua_GeneralAllocator_alloc_1(self, (size * 24), NELUA_NIL));
    if(NELUA_LIKELY((data != ((bwrapbox_limit_pair_arr0_ptr)NULL)))) {
      return (nelua_span_limit_pair_){.data = data, .size = size};
    }
  }
  return (nelua_span_limit_pair_){0};
}
nelua_span_cstring_ nelua_GeneralAllocator_spanalloc_4(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags) {
  if(NELUA_LIKELY((size > 0))) {
    nlcstring_arr0_ptr data = ((nlcstring_arr0_ptr)nelua_GeneralAllocator_alloc_1(self, (size * 8), NELUA_NIL));
    if(NELUA_LIKELY((data != ((nlcstring_arr0_ptr)NULL)))) {
      return (nelua_span_cstring_){.data = data, .size = size};
    }
  }
  return (nelua_span_cstring_){0};
}
nelua_span_usize_ nelua_GeneralAllocator_spanalloc_5(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags) {
  if(NELUA_LIKELY((size > 0))) {
    nlusize_arr0_ptr data = ((nlusize_arr0_ptr)nelua_GeneralAllocator_alloc_1(self, (size * 8), NELUA_NIL));
    if(NELUA_LIKELY((data != ((nlusize_arr0_ptr)NULL)))) {
      return (nelua_span_usize_){.data = data, .size = size};
    }
  }
  return (nelua_span_usize_){0};
}
nelua_span_uint8_ nelua_GeneralAllocator_spanalloc0_1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags) {
  if(NELUA_LIKELY((size > 0))) {
    nluint8_arr0_ptr data = ((nluint8_arr0_ptr)nelua_GeneralAllocator_alloc0_1(self, (size * 1), NELUA_NIL));
    if(NELUA_LIKELY((data != ((nluint8_arr0_ptr)NULL)))) {
      return (nelua_span_uint8_){.data = data, .size = size};
    }
  }
  return (nelua_span_uint8_){0};
}
nelua_span_hashmapnode_string__cint__ nelua_GeneralAllocator_spanalloc0_2(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags) {
  if(NELUA_LIKELY((size > 0))) {
    nelua_hashmapnode_string__cint__arr0_ptr data = ((nelua_hashmapnode_string__cint__arr0_ptr)nelua_GeneralAllocator_alloc0_1(self, (size * 32), NELUA_NIL));
    if(NELUA_LIKELY((data != ((nelua_hashmapnode_string__cint__arr0_ptr)NULL)))) {
      return (nelua_span_hashmapnode_string__cint__){.data = data, .size = size};
    }
  }
  return (nelua_span_hashmapnode_string__cint__){0};
}
void nelua_GeneralAllocator_spandealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_uint8_ s) {
  if(NELUA_UNLIKELY((s.size == 0))) {
    return;
  }
  nelua_GeneralAllocator_dealloc(self, (void*)s.data);
}
nelua_span_uint8_ nelua_GeneralAllocator_spanrealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_uint8_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc_2(self, NELUA_NIL, size, NELUA_NIL);
    return s;
  }
  nluint8_arr0_ptr p = ((nluint8_arr0_ptr)nelua_GeneralAllocator_realloc(self, (void*)s.data, (size * 1), (s.size * 1)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nluint8_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_string_ nelua_GeneralAllocator_spanrealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_string_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc_1(self, NELUA_NIL, size, NELUA_NIL);
    return s;
  }
  nlstring_arr0_ptr p = ((nlstring_arr0_ptr)nelua_GeneralAllocator_realloc(self, (void*)s.data, (size * 16), (s.size * 16)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nlstring_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_usize_ nelua_GeneralAllocator_spanrealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc_5(self, NELUA_NIL, size, NELUA_NIL);
    return s;
  }
  nlusize_arr0_ptr p = ((nlusize_arr0_ptr)nelua_GeneralAllocator_realloc(self, (void*)s.data, (size * 8), (s.size * 8)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nlusize_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_limit_pair_ nelua_GeneralAllocator_spanrealloc_4(nelua_GeneralAllocator_ptr self, nelua_span_limit_pair_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc_3(self, NELUA_NIL, size, NELUA_NIL);
    return s;
  }
  bwrapbox_limit_pair_arr0_ptr p = ((bwrapbox_limit_pair_arr0_ptr)nelua_GeneralAllocator_realloc(self, (void*)s.data, (size * 24), (s.size * 24)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((bwrapbox_limit_pair_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_cstring_ nelua_GeneralAllocator_spanrealloc_5(nelua_GeneralAllocator_ptr self, nelua_span_cstring_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc_4(self, NELUA_NIL, size, NELUA_NIL);
    return s;
  }
  nlcstring_arr0_ptr p = ((nlcstring_arr0_ptr)nelua_GeneralAllocator_realloc(self, (void*)s.data, (size * 8), (s.size * 8)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nlcstring_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_uint8_ nelua_GeneralAllocator_xspanrealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_uint8_ s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc_1(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_string_ nelua_GeneralAllocator_xspanrealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_string_ s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc_2(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_usize_ nelua_GeneralAllocator_xspanrealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc_3(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_limit_pair_ nelua_GeneralAllocator_xspanrealloc_4(nelua_GeneralAllocator_ptr self, nelua_span_limit_pair_ s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc_4(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_cstring_ nelua_GeneralAllocator_xspanrealloc_5(nelua_GeneralAllocator_ptr self, nelua_span_cstring_ s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc_5(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_uint8_ nelua_GeneralAllocator_spanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_uint8_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc0_1(self, NELUA_NIL, size, NELUA_NIL);
    return s;
  }
  nluint8_arr0_ptr p = ((nluint8_arr0_ptr)nelua_GeneralAllocator_realloc0(self, (void*)s.data, (size * 1), (s.size * 1)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nluint8_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_hashmapnode_string__cint__ nelua_GeneralAllocator_spanrealloc0_2(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_string__cint__ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc0_2(self, NELUA_NIL, size, NELUA_NIL);
    return s;
  }
  nelua_hashmapnode_string__cint__arr0_ptr p = ((nelua_hashmapnode_string__cint__arr0_ptr)nelua_GeneralAllocator_realloc0(self, (void*)s.data, (size * 32), (s.size * 32)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nelua_hashmapnode_string__cint__arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_hashmapnode_string__cint__ nelua_GeneralAllocator_xspanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_string__cint__ s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc0_2(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_sequenceimpl_string__1_ptr nelua_GeneralAllocator_new_3(nelua_GeneralAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags) {
  nelua_sequenceimpl_string__1_ptr ptr = ((nelua_sequenceimpl_string__1_ptr)nelua_GeneralAllocator_xalloc0_1(self, 24U, NELUA_NIL));
  return ptr;
}
nelua_sequenceimpl_limit_pair__ptr nelua_GeneralAllocator_new_4(nelua_GeneralAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags) {
  nelua_sequenceimpl_limit_pair__ptr ptr = ((nelua_sequenceimpl_limit_pair__ptr)nelua_GeneralAllocator_xalloc0_1(self, 24U, NELUA_NIL));
  return ptr;
}
nelua_sequenceimpl_cstring__ptr nelua_GeneralAllocator_new_5(nelua_GeneralAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags) {
  nelua_sequenceimpl_cstring__ptr ptr = ((nelua_sequenceimpl_cstring__ptr)nelua_GeneralAllocator_xalloc0_1(self, 24U, NELUA_NIL));
  return ptr;
}
void nelua_stringbuilderT_destroy(nelua_stringbuilderT_ptr self) {
  nelua_GeneralAllocator_spandealloc_1((&self->allocator), self->data);
  self->data = (nelua_span_uint8_){0};
  self->size = 0U;
}
bool nelua_stringbuilderT_grow(nelua_stringbuilderT_ptr self, uintptr_t newsize) {
  uintptr_t needed = (newsize + 1);
  uintptr_t cap = self->data.size;
  if((needed <= cap)) {
    return true;
  }
  if((cap == 0)) {
    cap = 16U;
  }
  while((cap < needed)) {
    cap = (cap * 2);
    if((cap <= 16U)) {
      return false;
    }
  }
  self->data = nelua_GeneralAllocator_spanrealloc0_1((&self->allocator), self->data, cap);
  if((self->data.size != cap)) {
    self->data = nelua_GeneralAllocator_spanrealloc0_1((&self->allocator), self->data, needed);
  }
  return (needed <= self->data.size);
}
nelua_span_uint8_ nelua_stringbuilderT_prepare(nelua_stringbuilderT_ptr self, uintptr_t n) {
  if((!nelua_stringbuilderT_grow(self, (self->size + n)))) {
    return (nelua_span_uint8_){0};
  }
  return (nelua_span_uint8_){.data = ((nluint8_arr0_ptr)(&(*nelua_span_uint8____atindex(self->data, self->size)))), .size = ((self->data.size - self->size) - 1)};
}
void nelua_stringbuilderT_commit(nelua_stringbuilderT_ptr self, uintptr_t n) {
  uintptr_t newsize = (self->size + n);
  self->size = newsize;
}
bool nelua_stringbuilderT_writebyte_1(nelua_stringbuilderT_ptr self, uint8_t c, nlniltype n) {
  nelua_span_uint8_ p = nelua_stringbuilderT_prepare(self, 1U);
  if(NELUA_UNLIKELY(nelua_span_uint8__empty(p))) {
    return false;
  }
  p.data[0] = c;
  self->size = (self->size + 1);
  return true;
}
nlmulret_nlboolean_nlusize nelua_stringbuilderT_write_1(nelua_stringbuilderT_ptr self, nlstring __arg1) {
  uintptr_t written = 0U;
  {
    nlstring s = __arg1;
    if((s.size > 0)) {
      nelua_span_uint8_ p = nelua_stringbuilderT_prepare(self, s.size);
      if(NELUA_UNLIKELY(nelua_span_uint8__empty(p))) {
        return (nlmulret_nlboolean_nlusize){false, written};
      }
      nelua_memory_copy((void*)p.data, (void*)s.data, s.size);
      written = (written + s.size);
      self->size = (self->size + s.size);
    }
  }
  return (nlmulret_nlboolean_nlusize){true, written};
}
nlmulret_nlboolean_nlisize nelua_formatarg_2(nelua_stringbuilderT_ptr self, uint8_t c, nluint8_arr32_ptr form, int arg1) {
  nelua_span_uint8_ buf = nelua_stringbuilderT_prepare(self, 128U);
  if((buf.size < 128U)) {
    return (nlmulret_nlboolean_nlisize){false, 0};
  }
  intptr_t nb = -1;
  if((c == 99U)) {
    int n = arg1;
    nb = (intptr_t)snprintf((char*)buf.data, 128U, (char*)(&form->v[0]), n);
    goto nelua_next_4;
  }
  if(((c == 100U) || (c == 105U))) {
    nelua_addlenmod(form, (char*)"lli", 2U);
    long long n = (long long)arg1;
    nb = (intptr_t)snprintf((char*)buf.data, 128U, (char*)(&form->v[0]), n);
    goto nelua_next_4;
  }
  if(((((c == 111U) || (c == 117U)) || (c == 120U)) || (c == 88U))) {
    nelua_addlenmod(form, (char*)"llu", 2U);
    unsigned long long n = (unsigned long long)(unsigned int)arg1;
    nb = (intptr_t)snprintf((char*)buf.data, 128U, (char*)(&form->v[0]), n);
    goto nelua_next_4;
  }
  if((((((((c == 97U) || (c == 65U)) || (c == 102U)) || (c == 101U)) || (c == 69U)) || (c == 103U)) || (c == 71U))) {
    double n = (double)arg1;
    nb = (intptr_t)snprintf((char*)buf.data, 128U, (char*)(&form->v[0]), n);
    goto nelua_next_4;
  }
  if((c == 115U)) {
    nlstring s = nelua_tostring_5(arg1);
    uintptr_t slen = (s.size + 1);
    if(((form->v[1] == c) && (form->v[2] == 0))) {
      buf = nelua_stringbuilderT_prepare(self, slen);
      if((buf.size < slen)) {
        return (nlmulret_nlboolean_nlisize){false, 0};
      }
      nelua_memory_copy((void*)buf.data, (void*)s.data, s.size);
      nb = (intptr_t)s.size;
    } else {
      if((slen < 128U)) {
        slen = 128U;
      }
      buf = nelua_stringbuilderT_prepare(self, slen);
      if((buf.size < slen)) {
        return (nlmulret_nlboolean_nlisize){false, 0};
      }
      char* cs = (char*)s.data;
      if((s.size == 0)) {
        cs = (char*)"";
      }
      nb = (intptr_t)snprintf((char*)buf.data, (size_t)buf.size, (char*)(&form->v[0]), cs);
    }
    nelua_nlstring_destroy((&s));
    goto nelua_next_4;
  }
  nelua_assert_msg_nlvoid(false, ((nlstring){(uint8_t*)"invalid format for argument", 27}));
nelua_next_4:;
  nelua_assert_msg_nlvoid((nb >= 0), ((nlstring){(uint8_t*)"unexpected number of bytes written in sprintf", 45}));
  return (nlmulret_nlboolean_nlisize){true, nb};
}
nlmulret_nlboolean_nlisize nelua_formatarg_3(nelua_stringbuilderT_ptr self, uint8_t c, nluint8_arr32_ptr form, int64_t arg1) {
  nelua_span_uint8_ buf = nelua_stringbuilderT_prepare(self, 128U);
  if((buf.size < 128U)) {
    return (nlmulret_nlboolean_nlisize){false, 0};
  }
  intptr_t nb = -1;
  if((c == 99U)) {
    int n = (int)arg1;
    nb = (intptr_t)snprintf((char*)buf.data, 128U, (char*)(&form->v[0]), n);
    goto nelua_next_11;
  }
  if(((c == 100U) || (c == 105U))) {
    nelua_addlenmod(form, (char*)"lli", 2U);
    long long n = (long long)arg1;
    nb = (intptr_t)snprintf((char*)buf.data, 128U, (char*)(&form->v[0]), n);
    goto nelua_next_11;
  }
  if(((((c == 111U) || (c == 117U)) || (c == 120U)) || (c == 88U))) {
    nelua_addlenmod(form, (char*)"llu", 2U);
    unsigned long long n = (unsigned long long)(uint64_t)arg1;
    nb = (intptr_t)snprintf((char*)buf.data, 128U, (char*)(&form->v[0]), n);
    goto nelua_next_11;
  }
  if((((((((c == 97U) || (c == 65U)) || (c == 102U)) || (c == 101U)) || (c == 69U)) || (c == 103U)) || (c == 71U))) {
    double n = (double)arg1;
    nb = (intptr_t)snprintf((char*)buf.data, 128U, (char*)(&form->v[0]), n);
    goto nelua_next_11;
  }
  if((c == 115U)) {
    nlstring s = nelua_tostring_4(arg1);
    uintptr_t slen = (s.size + 1);
    if(((form->v[1] == c) && (form->v[2] == 0))) {
      buf = nelua_stringbuilderT_prepare(self, slen);
      if((buf.size < slen)) {
        return (nlmulret_nlboolean_nlisize){false, 0};
      }
      nelua_memory_copy((void*)buf.data, (void*)s.data, s.size);
      nb = (intptr_t)s.size;
    } else {
      if((slen < 128U)) {
        slen = 128U;
      }
      buf = nelua_stringbuilderT_prepare(self, slen);
      if((buf.size < slen)) {
        return (nlmulret_nlboolean_nlisize){false, 0};
      }
      char* cs = (char*)s.data;
      if((s.size == 0)) {
        cs = (char*)"";
      }
      nb = (intptr_t)snprintf((char*)buf.data, (size_t)buf.size, (char*)(&form->v[0]), cs);
    }
    nelua_nlstring_destroy((&s));
    goto nelua_next_11;
  }
  nelua_assert_msg_nlvoid(false, ((nlstring){(uint8_t*)"invalid format for argument", 27}));
nelua_next_11:;
  nelua_assert_msg_nlvoid((nb >= 0), ((nlstring){(uint8_t*)"unexpected number of bytes written in sprintf", 45}));
  return (nlmulret_nlboolean_nlisize){true, nb};
}
nlmulret_nlboolean_nlisize nelua_formatarg_4(nelua_stringbuilderT_ptr self, uint8_t c, nluint8_arr32_ptr form, nlstring arg1) {
  nelua_span_uint8_ buf = nelua_stringbuilderT_prepare(self, 128U);
  if((buf.size < 128U)) {
    return (nlmulret_nlboolean_nlisize){false, 0};
  }
  intptr_t nb = -1;
  if((c == 115U)) {
    nlstring s = arg1;
    uintptr_t slen = (s.size + 1);
    if(((form->v[1] == c) && (form->v[2] == 0))) {
      buf = nelua_stringbuilderT_prepare(self, slen);
      if((buf.size < slen)) {
        return (nlmulret_nlboolean_nlisize){false, 0};
      }
      nelua_memory_copy((void*)buf.data, (void*)s.data, s.size);
      nb = (intptr_t)s.size;
    } else {
      if((slen < 128U)) {
        slen = 128U;
      }
      buf = nelua_stringbuilderT_prepare(self, slen);
      if((buf.size < slen)) {
        return (nlmulret_nlboolean_nlisize){false, 0};
      }
      s = nelua_nlstring_copy(s);
      char* cs = (char*)s.data;
      if((s.size == 0)) {
        cs = (char*)"";
      }
      nb = (intptr_t)snprintf((char*)buf.data, (size_t)buf.size, (char*)(&form->v[0]), cs);
      nelua_nlstring_destroy((&s));
    }
    goto nelua_next_12;
  }
  nelua_assert_msg_nlvoid(false, ((nlstring){(uint8_t*)"invalid format for argument", 27}));
nelua_next_12:;
  nelua_assert_msg_nlvoid((nb >= 0), ((nlstring){(uint8_t*)"unexpected number of bytes written in sprintf", 45}));
  return (nlmulret_nlboolean_nlisize){true, nb};
}
nlmulret_nlboolean_nlusize nelua_stringbuilderT_writef_2(nelua_stringbuilderT_ptr self, nlstring fmt, int __arg1) {
  uintptr_t pos = 0U;
  uintptr_t written = 0U;
  int32_t argi = 0;
  while((pos < fmt.size)) {
    uint8_t c = fmt.data[pos];
    pos = (pos + 1);
    if((c != 37U)) {
      if((!nelua_stringbuilderT_writebyte_1(self, c, NELUA_NIL))) {
        return (nlmulret_nlboolean_nlusize){false, written};
      }
      written = (written + 1);
    } else {
      c = fmt.data[pos];
      if((c == 37U)) {
        if((!nelua_stringbuilderT_writebyte_1(self, 37U, NELUA_NIL))) {
          return (nlmulret_nlboolean_nlusize){false, written};
        }
        written = (written + 1);
        pos = (pos + 1);
      } else {
        nluint8_arr32 form = (nluint8_arr32){0};
        pos = (pos + nelua_scanformat(((nluint8_arr0_ptr)(&fmt.data[pos])), (&form)));
        c = fmt.data[pos];
        pos = (pos + 1);
        argi = (argi + 1);
        bool ok = false;
        intptr_t nb = -1;
        if((1 == argi)) {
          nlmulret_nlboolean_nlisize _asgnret_1 = nelua_formatarg_2(self, c, (&form), __arg1);
          ok = _asgnret_1.r1;
          nb = _asgnret_1.r2;
          goto nelua_next_3;
        }
        nelua_assert_msg_nlvoid(false, ((nlstring){(uint8_t*)"bad format argument (no value)", 30}));
nelua_next_3:;
        if((!ok)) {
          return (nlmulret_nlboolean_nlusize){false, written};
        }
        nelua_stringbuilderT_commit(self, (uintptr_t)nb);
        written = (written + (uintptr_t)nb);
      }
    }
  }
  return (nlmulret_nlboolean_nlusize){true, written};
}
nlmulret_nlboolean_nlusize nelua_stringbuilderT_writef_3(nelua_stringbuilderT_ptr self, nlstring fmt, int64_t __arg1, int64_t __arg2) {
  uintptr_t pos = 0U;
  uintptr_t written = 0U;
  int32_t argi = 0;
  while((pos < fmt.size)) {
    uint8_t c = fmt.data[pos];
    pos = (pos + 1);
    if((c != 37U)) {
      if((!nelua_stringbuilderT_writebyte_1(self, c, NELUA_NIL))) {
        return (nlmulret_nlboolean_nlusize){false, written};
      }
      written = (written + 1);
    } else {
      c = fmt.data[pos];
      if((c == 37U)) {
        if((!nelua_stringbuilderT_writebyte_1(self, 37U, NELUA_NIL))) {
          return (nlmulret_nlboolean_nlusize){false, written};
        }
        written = (written + 1);
        pos = (pos + 1);
      } else {
        nluint8_arr32 form = (nluint8_arr32){0};
        pos = (pos + nelua_scanformat(((nluint8_arr0_ptr)(&fmt.data[pos])), (&form)));
        c = fmt.data[pos];
        pos = (pos + 1);
        argi = (argi + 1);
        bool ok = false;
        intptr_t nb = -1;
        if((1 == argi)) {
          nlmulret_nlboolean_nlisize _asgnret_1 = nelua_formatarg_3(self, c, (&form), __arg1);
          ok = _asgnret_1.r1;
          nb = _asgnret_1.r2;
          goto nelua_next_5;
        }
        if((2 == argi)) {
          nlmulret_nlboolean_nlisize _asgnret_2 = nelua_formatarg_3(self, c, (&form), __arg2);
          ok = _asgnret_2.r1;
          nb = _asgnret_2.r2;
          goto nelua_next_5;
        }
        nelua_assert_msg_nlvoid(false, ((nlstring){(uint8_t*)"bad format argument (no value)", 30}));
nelua_next_5:;
        if((!ok)) {
          return (nlmulret_nlboolean_nlusize){false, written};
        }
        nelua_stringbuilderT_commit(self, (uintptr_t)nb);
        written = (written + (uintptr_t)nb);
      }
    }
  }
  return (nlmulret_nlboolean_nlusize){true, written};
}
nlmulret_nlboolean_nlusize nelua_stringbuilderT_writef_4(nelua_stringbuilderT_ptr self, nlstring fmt, nlstring __arg1, int __arg2, int64_t __arg3, int64_t __arg4) {
  uintptr_t pos = 0U;
  uintptr_t written = 0U;
  int32_t argi = 0;
  while((pos < fmt.size)) {
    uint8_t c = fmt.data[pos];
    pos = (pos + 1);
    if((c != 37U)) {
      if((!nelua_stringbuilderT_writebyte_1(self, c, NELUA_NIL))) {
        return (nlmulret_nlboolean_nlusize){false, written};
      }
      written = (written + 1);
    } else {
      c = fmt.data[pos];
      if((c == 37U)) {
        if((!nelua_stringbuilderT_writebyte_1(self, 37U, NELUA_NIL))) {
          return (nlmulret_nlboolean_nlusize){false, written};
        }
        written = (written + 1);
        pos = (pos + 1);
      } else {
        nluint8_arr32 form = (nluint8_arr32){0};
        pos = (pos + nelua_scanformat(((nluint8_arr0_ptr)(&fmt.data[pos])), (&form)));
        c = fmt.data[pos];
        pos = (pos + 1);
        argi = (argi + 1);
        bool ok = false;
        intptr_t nb = -1;
        if((1 == argi)) {
          nlmulret_nlboolean_nlisize _asgnret_1 = nelua_formatarg_4(self, c, (&form), __arg1);
          ok = _asgnret_1.r1;
          nb = _asgnret_1.r2;
          goto nelua_next_6;
        }
        if((2 == argi)) {
          nlmulret_nlboolean_nlisize _asgnret_2 = nelua_formatarg_2(self, c, (&form), __arg2);
          ok = _asgnret_2.r1;
          nb = _asgnret_2.r2;
          goto nelua_next_6;
        }
        if((3 == argi)) {
          nlmulret_nlboolean_nlisize _asgnret_3 = nelua_formatarg_3(self, c, (&form), __arg3);
          ok = _asgnret_3.r1;
          nb = _asgnret_3.r2;
          goto nelua_next_6;
        }
        if((4 == argi)) {
          nlmulret_nlboolean_nlisize _asgnret_4 = nelua_formatarg_3(self, c, (&form), __arg4);
          ok = _asgnret_4.r1;
          nb = _asgnret_4.r2;
          goto nelua_next_6;
        }
        nelua_assert_msg_nlvoid(false, ((nlstring){(uint8_t*)"bad format argument (no value)", 30}));
nelua_next_6:;
        if((!ok)) {
          return (nlmulret_nlboolean_nlusize){false, written};
        }
        nelua_stringbuilderT_commit(self, (uintptr_t)nb);
        written = (written + (uintptr_t)nb);
      }
    }
  }
  return (nlmulret_nlboolean_nlusize){true, written};
}
nlmulret_nlboolean_nlusize nelua_stringbuilderT_writef_5(nelua_stringbuilderT_ptr self, nlstring fmt) {
  uintptr_t pos = 0U;
  uintptr_t written = 0U;
  int32_t argi = 0;
  while((pos < fmt.size)) {
    uint8_t c = fmt.data[pos];
    pos = (pos + 1);
    if((c != 37U)) {
      if((!nelua_stringbuilderT_writebyte_1(self, c, NELUA_NIL))) {
        return (nlmulret_nlboolean_nlusize){false, written};
      }
      written = (written + 1);
    } else {
      c = fmt.data[pos];
      if((c == 37U)) {
        if((!nelua_stringbuilderT_writebyte_1(self, 37U, NELUA_NIL))) {
          return (nlmulret_nlboolean_nlusize){false, written};
        }
        written = (written + 1);
        pos = (pos + 1);
      } else {
        nluint8_arr32 form = (nluint8_arr32){0};
        pos = (pos + nelua_scanformat(((nluint8_arr0_ptr)(&fmt.data[pos])), (&form)));
        c = fmt.data[pos];
        pos = (pos + 1);
        argi = (argi + 1);
        bool ok = false;
        intptr_t nb = -1;
        nelua_assert_msg_nlvoid(false, ((nlstring){(uint8_t*)"bad format argument (no value)", 30}));
        if((!ok)) {
          return (nlmulret_nlboolean_nlusize){false, written};
        }
        nelua_stringbuilderT_commit(self, (uintptr_t)nb);
        written = (written + (uintptr_t)nb);
      }
    }
  }
  return (nlmulret_nlboolean_nlusize){true, written};
}
nlmulret_nlboolean_nlusize nelua_stringbuilderT_writef_6(nelua_stringbuilderT_ptr self, nlstring fmt, nlstring __arg1, nlstring __arg2) {
  uintptr_t pos = 0U;
  uintptr_t written = 0U;
  int32_t argi = 0;
  while((pos < fmt.size)) {
    uint8_t c = fmt.data[pos];
    pos = (pos + 1);
    if((c != 37U)) {
      if((!nelua_stringbuilderT_writebyte_1(self, c, NELUA_NIL))) {
        return (nlmulret_nlboolean_nlusize){false, written};
      }
      written = (written + 1);
    } else {
      c = fmt.data[pos];
      if((c == 37U)) {
        if((!nelua_stringbuilderT_writebyte_1(self, 37U, NELUA_NIL))) {
          return (nlmulret_nlboolean_nlusize){false, written};
        }
        written = (written + 1);
        pos = (pos + 1);
      } else {
        nluint8_arr32 form = (nluint8_arr32){0};
        pos = (pos + nelua_scanformat(((nluint8_arr0_ptr)(&fmt.data[pos])), (&form)));
        c = fmt.data[pos];
        pos = (pos + 1);
        argi = (argi + 1);
        bool ok = false;
        intptr_t nb = -1;
        if((1 == argi)) {
          nlmulret_nlboolean_nlisize _asgnret_1 = nelua_formatarg_4(self, c, (&form), __arg1);
          ok = _asgnret_1.r1;
          nb = _asgnret_1.r2;
          goto nelua_next_8;
        }
        if((2 == argi)) {
          nlmulret_nlboolean_nlisize _asgnret_2 = nelua_formatarg_4(self, c, (&form), __arg2);
          ok = _asgnret_2.r1;
          nb = _asgnret_2.r2;
          goto nelua_next_8;
        }
        nelua_assert_msg_nlvoid(false, ((nlstring){(uint8_t*)"bad format argument (no value)", 30}));
nelua_next_8:;
        if((!ok)) {
          return (nlmulret_nlboolean_nlusize){false, written};
        }
        nelua_stringbuilderT_commit(self, (uintptr_t)nb);
        written = (written + (uintptr_t)nb);
      }
    }
  }
  return (nlmulret_nlboolean_nlusize){true, written};
}
nlmulret_nlboolean_nlusize nelua_stringbuilderT_writef_7(nelua_stringbuilderT_ptr self, nlstring fmt, int __arg1, nlstring __arg2, nlstring __arg3) {
  uintptr_t pos = 0U;
  uintptr_t written = 0U;
  int32_t argi = 0;
  while((pos < fmt.size)) {
    uint8_t c = fmt.data[pos];
    pos = (pos + 1);
    if((c != 37U)) {
      if((!nelua_stringbuilderT_writebyte_1(self, c, NELUA_NIL))) {
        return (nlmulret_nlboolean_nlusize){false, written};
      }
      written = (written + 1);
    } else {
      c = fmt.data[pos];
      if((c == 37U)) {
        if((!nelua_stringbuilderT_writebyte_1(self, 37U, NELUA_NIL))) {
          return (nlmulret_nlboolean_nlusize){false, written};
        }
        written = (written + 1);
        pos = (pos + 1);
      } else {
        nluint8_arr32 form = (nluint8_arr32){0};
        pos = (pos + nelua_scanformat(((nluint8_arr0_ptr)(&fmt.data[pos])), (&form)));
        c = fmt.data[pos];
        pos = (pos + 1);
        argi = (argi + 1);
        bool ok = false;
        intptr_t nb = -1;
        if((1 == argi)) {
          nlmulret_nlboolean_nlisize _asgnret_1 = nelua_formatarg_2(self, c, (&form), __arg1);
          ok = _asgnret_1.r1;
          nb = _asgnret_1.r2;
          goto nelua_next_9;
        }
        if((2 == argi)) {
          nlmulret_nlboolean_nlisize _asgnret_2 = nelua_formatarg_4(self, c, (&form), __arg2);
          ok = _asgnret_2.r1;
          nb = _asgnret_2.r2;
          goto nelua_next_9;
        }
        if((3 == argi)) {
          nlmulret_nlboolean_nlisize _asgnret_3 = nelua_formatarg_4(self, c, (&form), __arg3);
          ok = _asgnret_3.r1;
          nb = _asgnret_3.r2;
          goto nelua_next_9;
        }
        nelua_assert_msg_nlvoid(false, ((nlstring){(uint8_t*)"bad format argument (no value)", 30}));
nelua_next_9:;
        if((!ok)) {
          return (nlmulret_nlboolean_nlusize){false, written};
        }
        nelua_stringbuilderT_commit(self, (uintptr_t)nb);
        written = (written + (uintptr_t)nb);
      }
    }
  }
  return (nlmulret_nlboolean_nlusize){true, written};
}
nlmulret_nlboolean_nlusize nelua_stringbuilderT_writef_8(nelua_stringbuilderT_ptr self, nlstring fmt, nlstring __arg1) {
  uintptr_t pos = 0U;
  uintptr_t written = 0U;
  int32_t argi = 0;
  while((pos < fmt.size)) {
    uint8_t c = fmt.data[pos];
    pos = (pos + 1);
    if((c != 37U)) {
      if((!nelua_stringbuilderT_writebyte_1(self, c, NELUA_NIL))) {
        return (nlmulret_nlboolean_nlusize){false, written};
      }
      written = (written + 1);
    } else {
      c = fmt.data[pos];
      if((c == 37U)) {
        if((!nelua_stringbuilderT_writebyte_1(self, 37U, NELUA_NIL))) {
          return (nlmulret_nlboolean_nlusize){false, written};
        }
        written = (written + 1);
        pos = (pos + 1);
      } else {
        nluint8_arr32 form = (nluint8_arr32){0};
        pos = (pos + nelua_scanformat(((nluint8_arr0_ptr)(&fmt.data[pos])), (&form)));
        c = fmt.data[pos];
        pos = (pos + 1);
        argi = (argi + 1);
        bool ok = false;
        intptr_t nb = -1;
        if((1 == argi)) {
          nlmulret_nlboolean_nlisize _asgnret_1 = nelua_formatarg_4(self, c, (&form), __arg1);
          ok = _asgnret_1.r1;
          nb = _asgnret_1.r2;
          goto nelua_next_10;
        }
        nelua_assert_msg_nlvoid(false, ((nlstring){(uint8_t*)"bad format argument (no value)", 30}));
nelua_next_10:;
        if((!ok)) {
          return (nlmulret_nlboolean_nlusize){false, written};
        }
        nelua_stringbuilderT_commit(self, (uintptr_t)nb);
        written = (written + (uintptr_t)nb);
      }
    }
  }
  return (nlmulret_nlboolean_nlusize){true, written};
}
nlmulret_nlboolean_nlusize nelua_stringbuilderT_writef_9(nelua_stringbuilderT_ptr self, nlstring fmt, nlstring __arg1, nlstring __arg2, nlstring __arg3) {
  uintptr_t pos = 0U;
  uintptr_t written = 0U;
  int32_t argi = 0;
  while((pos < fmt.size)) {
    uint8_t c = fmt.data[pos];
    pos = (pos + 1);
    if((c != 37U)) {
      if((!nelua_stringbuilderT_writebyte_1(self, c, NELUA_NIL))) {
        return (nlmulret_nlboolean_nlusize){false, written};
      }
      written = (written + 1);
    } else {
      c = fmt.data[pos];
      if((c == 37U)) {
        if((!nelua_stringbuilderT_writebyte_1(self, 37U, NELUA_NIL))) {
          return (nlmulret_nlboolean_nlusize){false, written};
        }
        written = (written + 1);
        pos = (pos + 1);
      } else {
        nluint8_arr32 form = (nluint8_arr32){0};
        pos = (pos + nelua_scanformat(((nluint8_arr0_ptr)(&fmt.data[pos])), (&form)));
        c = fmt.data[pos];
        pos = (pos + 1);
        argi = (argi + 1);
        bool ok = false;
        intptr_t nb = -1;
        if((1 == argi)) {
          nlmulret_nlboolean_nlisize _asgnret_1 = nelua_formatarg_4(self, c, (&form), __arg1);
          ok = _asgnret_1.r1;
          nb = _asgnret_1.r2;
          goto nelua_next_13;
        }
        if((2 == argi)) {
          nlmulret_nlboolean_nlisize _asgnret_2 = nelua_formatarg_4(self, c, (&form), __arg2);
          ok = _asgnret_2.r1;
          nb = _asgnret_2.r2;
          goto nelua_next_13;
        }
        if((3 == argi)) {
          nlmulret_nlboolean_nlisize _asgnret_3 = nelua_formatarg_4(self, c, (&form), __arg3);
          ok = _asgnret_3.r1;
          nb = _asgnret_3.r2;
          goto nelua_next_13;
        }
        nelua_assert_msg_nlvoid(false, ((nlstring){(uint8_t*)"bad format argument (no value)", 30}));
nelua_next_13:;
        if((!ok)) {
          return (nlmulret_nlboolean_nlusize){false, written};
        }
        nelua_stringbuilderT_commit(self, (uintptr_t)nb);
        written = (written + (uintptr_t)nb);
      }
    }
  }
  return (nlmulret_nlboolean_nlusize){true, written};
}
nlmulret_nlboolean_nlusize nelua_stringbuilderT_writef_10(nelua_stringbuilderT_ptr self, nlstring fmt, nlstring __arg1, int64_t __arg2) {
  uintptr_t pos = 0U;
  uintptr_t written = 0U;
  int32_t argi = 0;
  while((pos < fmt.size)) {
    uint8_t c = fmt.data[pos];
    pos = (pos + 1);
    if((c != 37U)) {
      if((!nelua_stringbuilderT_writebyte_1(self, c, NELUA_NIL))) {
        return (nlmulret_nlboolean_nlusize){false, written};
      }
      written = (written + 1);
    } else {
      c = fmt.data[pos];
      if((c == 37U)) {
        if((!nelua_stringbuilderT_writebyte_1(self, 37U, NELUA_NIL))) {
          return (nlmulret_nlboolean_nlusize){false, written};
        }
        written = (written + 1);
        pos = (pos + 1);
      } else {
        nluint8_arr32 form = (nluint8_arr32){0};
        pos = (pos + nelua_scanformat(((nluint8_arr0_ptr)(&fmt.data[pos])), (&form)));
        c = fmt.data[pos];
        pos = (pos + 1);
        argi = (argi + 1);
        bool ok = false;
        intptr_t nb = -1;
        if((1 == argi)) {
          nlmulret_nlboolean_nlisize _asgnret_1 = nelua_formatarg_4(self, c, (&form), __arg1);
          ok = _asgnret_1.r1;
          nb = _asgnret_1.r2;
          goto nelua_next_14;
        }
        if((2 == argi)) {
          nlmulret_nlboolean_nlisize _asgnret_2 = nelua_formatarg_3(self, c, (&form), __arg2);
          ok = _asgnret_2.r1;
          nb = _asgnret_2.r2;
          goto nelua_next_14;
        }
        nelua_assert_msg_nlvoid(false, ((nlstring){(uint8_t*)"bad format argument (no value)", 30}));
nelua_next_14:;
        if((!ok)) {
          return (nlmulret_nlboolean_nlusize){false, written};
        }
        nelua_stringbuilderT_commit(self, (uintptr_t)nb);
        written = (written + (uintptr_t)nb);
      }
    }
  }
  return (nlmulret_nlboolean_nlusize){true, written};
}
nlstring nelua_stringbuilderT_view(nelua_stringbuilderT_ptr self) {
  if(NELUA_UNLIKELY((self->size == 0))) {
    return (nlstring){0};
  }
  return (nlstring){.data = ((nluint8_arr0_ptr)(&(*nelua_span_uint8____atindex(self->data, 0U)))), .size = self->size};
}
nlstring nelua_stringbuilderT_promote(nelua_stringbuilderT_ptr self) {
  if(NELUA_UNLIKELY((self->size == 0))) {
    nelua_stringbuilderT_destroy(self);
    return (nlstring){0};
  }
  uintptr_t size = self->size;
  nelua_span_uint8_ data = nelua_GeneralAllocator_xspanrealloc_1((&self->allocator), self->data, (size + 1));
  (*nelua_span_uint8____atindex(data, size)) = 0U;
  self->data = (nelua_span_uint8_){0};
  self->size = 0U;
  return (nlstring){.data = data.data, .size = size};
}
void nelua_sequence_string__1__init(nelua_sequence_string__1_ptr self) {
  if(NELUA_LIKELY((self->impl != NULL))) {
    return;
  }
  self->impl = nelua_GeneralAllocator_new_3((&self->allocator), NELUA_NIL, NELUA_NIL, NELUA_NIL);
}
void nelua_sequence_string__1_reserve(nelua_sequence_string__1_ptr self, uintptr_t n) {
  nelua_sequence_string__1__init(self);
  uintptr_t cap = (n + 1);
  uintptr_t curcap = self->impl->data.size;
  if((curcap >= cap)) {
    return;
  }
  self->impl->data = nelua_GeneralAllocator_xspanrealloc_2((&self->allocator), self->impl->data, cap);
  if(NELUA_UNLIKELY((curcap == 0))) {
    (*nelua_span_string____atindex(self->impl->data, 0U)) = (nlstring){0};
  }
}
void nelua_sequenceT_grow_1(nelua_sequence_string__1_ptr self) {
  uintptr_t cap = 2U;
  uintptr_t curcap = self->impl->data.size;
  if(NELUA_LIKELY((curcap != 0))) {
    cap = (curcap * 2);
  }
  self->impl->data = nelua_GeneralAllocator_xspanrealloc_2((&self->allocator), self->impl->data, cap);
  if(NELUA_UNLIKELY((curcap == 0))) {
    (*nelua_span_string____atindex(self->impl->data, 0U)) = (nlstring){0};
  }
}
nlstring_ptr nelua_sequence_string__1___atindex(nelua_sequence_string__1_ptr self, uintptr_t pos) {
  nelua_sequence_string__1__init(self);
  if(NELUA_UNLIKELY((pos > self->impl->size))) {
    nelua_assert_msg_nlvoid((pos == (self->impl->size + 1)), ((nlstring){(uint8_t*)"position out of bounds", 22}));
    self->impl->size = (self->impl->size + 1);
    if(NELUA_UNLIKELY(((self->impl->size + 1) > self->impl->data.size))) {
      nelua_sequenceT_grow_1(self);
    }
    (*nelua_span_string____atindex(self->impl->data, pos)) = (nlstring){0};
  } else if(NELUA_UNLIKELY(((self->impl->data.size == 0) && (pos == 0)))) {
    nelua_sequenceT_grow_1(self);
  }
  return (&(*nelua_span_string____atindex(self->impl->data, pos)));
}
intptr_t nelua_sequence_string__1___len(nelua_sequence_string__1_ptr self) {
  if(NELUA_UNLIKELY((!(self->impl != NULL)))) {
    return 0;
  }
  return (intptr_t)self->impl->size;
}
void nelua_sequence_limit_pair___init(nelua_sequence_limit_pair__ptr self) {
  if(NELUA_LIKELY((self->impl != NULL))) {
    return;
  }
  self->impl = nelua_GeneralAllocator_new_4((&self->allocator), NELUA_NIL, NELUA_NIL, NELUA_NIL);
}
void nelua_sequenceT_grow_2(nelua_sequence_limit_pair__ptr self) {
  uintptr_t cap = 2U;
  uintptr_t curcap = self->impl->data.size;
  if(NELUA_LIKELY((curcap != 0))) {
    cap = (curcap * 2);
  }
  self->impl->data = nelua_GeneralAllocator_xspanrealloc_4((&self->allocator), self->impl->data, cap);
  if(NELUA_UNLIKELY((curcap == 0))) {
    (*nelua_span_limit_pair____atindex(self->impl->data, 0U)) = (bwrapbox_limit_pair){0};
  }
}
void nelua_sequence_limit_pair__push(nelua_sequence_limit_pair__ptr self, bwrapbox_limit_pair v) {
  nelua_sequence_limit_pair___init(self);
  self->impl->size = (self->impl->size + 1);
  if(NELUA_UNLIKELY(((self->impl->size + 1) >= self->impl->data.size))) {
    nelua_sequenceT_grow_2(self);
  }
  (*nelua_span_limit_pair____atindex(self->impl->data, self->impl->size)) = v;
}
bwrapbox_limit_pair_ptr nelua_sequence_limit_pair____atindex(nelua_sequence_limit_pair__ptr self, uintptr_t pos) {
  nelua_sequence_limit_pair___init(self);
  if(NELUA_UNLIKELY((pos > self->impl->size))) {
    nelua_assert_msg_nlvoid((pos == (self->impl->size + 1)), ((nlstring){(uint8_t*)"position out of bounds", 22}));
    self->impl->size = (self->impl->size + 1);
    if(NELUA_UNLIKELY(((self->impl->size + 1) > self->impl->data.size))) {
      nelua_sequenceT_grow_2(self);
    }
    (*nelua_span_limit_pair____atindex(self->impl->data, pos)) = (bwrapbox_limit_pair){0};
  } else if(NELUA_UNLIKELY(((self->impl->data.size == 0) && (pos == 0)))) {
    nelua_sequenceT_grow_2(self);
  }
  return (&(*nelua_span_limit_pair____atindex(self->impl->data, pos)));
}
intptr_t nelua_sequence_limit_pair____len(nelua_sequence_limit_pair__ptr self) {
  if(NELUA_UNLIKELY((!(self->impl != NULL)))) {
    return 0;
  }
  return (intptr_t)self->impl->size;
}
void nelua_sequence_cstring___init(nelua_sequence_cstring__ptr self) {
  if(NELUA_LIKELY((self->impl != NULL))) {
    return;
  }
  self->impl = nelua_GeneralAllocator_new_5((&self->allocator), NELUA_NIL, NELUA_NIL, NELUA_NIL);
}
void nelua_sequenceT_grow_3(nelua_sequence_cstring__ptr self) {
  uintptr_t cap = 2U;
  uintptr_t curcap = self->impl->data.size;
  if(NELUA_LIKELY((curcap != 0))) {
    cap = (curcap * 2);
  }
  self->impl->data = nelua_GeneralAllocator_xspanrealloc_5((&self->allocator), self->impl->data, cap);
  if(NELUA_UNLIKELY((curcap == 0))) {
    (*nelua_span_cstring____atindex(self->impl->data, 0U)) = NULL;
  }
}
void nelua_sequence_cstring__push(nelua_sequence_cstring__ptr self, char* v) {
  nelua_sequence_cstring___init(self);
  self->impl->size = (self->impl->size + 1);
  if(NELUA_UNLIKELY(((self->impl->size + 1) >= self->impl->data.size))) {
    nelua_sequenceT_grow_3(self);
  }
  (*nelua_span_cstring____atindex(self->impl->data, self->impl->size)) = v;
}
nlcstring_ptr nelua_sequence_cstring____atindex(nelua_sequence_cstring__ptr self, uintptr_t pos) {
  nelua_sequence_cstring___init(self);
  if(NELUA_UNLIKELY((pos > self->impl->size))) {
    nelua_assert_msg_nlvoid((pos == (self->impl->size + 1)), ((nlstring){(uint8_t*)"position out of bounds", 22}));
    self->impl->size = (self->impl->size + 1);
    if(NELUA_UNLIKELY(((self->impl->size + 1) > self->impl->data.size))) {
      nelua_sequenceT_grow_3(self);
    }
    (*nelua_span_cstring____atindex(self->impl->data, pos)) = NULL;
  } else if(NELUA_UNLIKELY(((self->impl->data.size == 0) && (pos == 0)))) {
    nelua_sequenceT_grow_3(self);
  }
  return (&(*nelua_span_cstring____atindex(self->impl->data, pos)));
}
nlstring nelua_nlstring_create(uintptr_t size) {
  nlstring s = (nlstring){.data = ((nluint8_arr0_ptr)nelua_GeneralAllocator_xalloc_1((&nelua_general_allocator), (size + 1), NELUA_NIL)), .size = size};
  s.data[size] = 0U;
  return s;
}
void nelua_nlstring_destroy(nlstring_ptr self) {
  if(NELUA_UNLIKELY((self->size == 0))) {
    return;
  }
  nelua_GeneralAllocator_dealloc((&nelua_general_allocator), (void*)self->data);
  self->data = ((nluint8_arr0_ptr)NULL);
  self->size = 0U;
}
nlstring nelua_nlstring_copy(nlstring s) {
  nlstring clone = (nlstring){0};
  if(NELUA_UNLIKELY((s.size == 0))) {
    return clone;
  }
  clone.data = ((nluint8_arr0_ptr)nelua_GeneralAllocator_xalloc_1((&nelua_general_allocator), (s.size + 1), NELUA_NIL));
  nelua_memory_copy((void*)clone.data, (void*)s.data, s.size);
  clone.data[s.size] = 0U;
  clone.size = s.size;
  return clone;
}
nlstring nelua_nlstring_subview_1(nlstring s, intptr_t i, intptr_t j) {
  intptr_t size = (intptr_t)s.size;
  if(NELUA_UNLIKELY((size == 0))) {
    return (nlstring){0};
  }
  if(NELUA_UNLIKELY((i < 0))) {
    i = ((size + i) + 1);
  }
  if(NELUA_UNLIKELY((i <= 0))) {
    i = 1;
  }
  if(NELUA_UNLIKELY((j < 0))) {
    j = ((size + j) + 1);
  }
  if(NELUA_UNLIKELY((j > size))) {
    j = size;
  }
  if(NELUA_UNLIKELY(((i == 1) && (j == size)))) {
    return s;
  }
  if(NELUA_UNLIKELY((i > j))) {
    return (nlstring){0};
  }
  uintptr_t subsize = (uintptr_t)((j - i) + 1);
  if(NELUA_UNLIKELY((subsize == 0))) {
    return (nlstring){0};
  }
  return (nlstring){.data = ((nluint8_arr0_ptr)(&s.data[(i - 1)])), .size = subsize};
}
nlstring nelua_nlstring_format_2(nlstring fmt, int __arg1) {
  nelua_stringbuilderT sb = (nelua_stringbuilderT){0};
  nelua_stringbuilderT_writef_2((&sb), fmt, __arg1);
  return nelua_stringbuilderT_promote((&sb));
}
nlstring nelua_nlstring_concat_1(nelua_span_string_ list, nlniltype sep) {
  nlstring sep_1 = ((nlstring){(uint8_t*)"", 0});
  uintptr_t size = 0U;
  for(uintptr_t i = 0U, _end = list.size; i < _end; i += 1) {
    if((i > 0)) {
      size = (size + sep_1.size);
    }
    size = (size + (*nelua_span_string____atindex(list, i)).size);
  }
  if((size == 0)) {
    return (nlstring){0};
  }
  nlstring s = nelua_nlstring_create(size);
  uintptr_t pos = 0U;
  for(uintptr_t i = 0U, _end = list.size; i < _end; i += 1) {
    if(((sep_1.size > 0) && (i > 0))) {
      for(uintptr_t j = 0U, _end = sep_1.size; j < _end; j += 1) {
        s.data[pos] = sep_1.data[j];
        pos = (pos + 1);
      }
    }
    nlstring part = (*nelua_span_string____atindex(list, i));
    for(uintptr_t j = 0U, _end = part.size; j < _end; j += 1) {
      s.data[pos] = part.data[j];
      pos = (pos + 1);
    }
  }
  return s;
}
void nelua_nlstring___close(nlstring_ptr self) {
  nelua_nlstring_destroy(self);
}
nluint8_ptr nelua_nlstring___atindex(nlstring s, uintptr_t i) {
  return (&s.data[(i - 1)]);
}
intptr_t nelua_nlstring___len(nlstring a) {
  return (intptr_t)a.size;
}
nlstring nelua_nlstring___concat_2(nlstring a, nlstring b) {
  if((a.size == 0)) {
    return nelua_nlstring_copy(b);
  } else if((b.size == 0)) {
    return nelua_nlstring_copy(a);
  }
  nlstring s = nelua_nlstring_create((a.size + b.size));
  nelua_memory_copy((void*)s.data, (void*)a.data, a.size);
  nelua_memory_copy((void*)(&s.data[a.size]), (void*)b.data, b.size);
  return s;
}
bool nelua_nlstring___eq(nlstring a, nlstring b) {
  return ((a.size == b.size) && (((a.data == b.data) || (a.size == 0)) || nelua_memory_equals((void*)a.data, (void*)b.data, a.size)));
}
bool nelua_StrPattCapture_is_unfinished(nelua_StrPattCapture_ptr self) {
  return (self->len == -1);
}
bool nelua_StrPattCapture_is_position(nelua_StrPattCapture_ptr self) {
  return (self->len == -2);
}
bool nelua_match_has_pattern_specials(nlstring pattern) {
  for(uintptr_t i = 0U, _end = pattern.size; i < _end; i += 1) {
    switch(pattern.data[i]) {
      case 94U:
      case 36U:
      case 42U:
      case 43U:
      case 63U:
      case 46U:
      case 40U:
      case 91U:
      case 37U:
      case 45U: {
        return true;
      }
    }
  }
  return false;
}
bool nelua_match_has_pattern_anchor(nlstring pattern) {
  return ((pattern.size > 0) && (pattern.data[0] == 94U));
}
nelua_StrPatt_1 nelua_StrPatt_1_create(nlstring source, nlstring pattern, bool plain) {
  if((!nelua_match_has_pattern_specials(pattern))) {
    plain = false;
  }
  bool anchor = ((!plain) && nelua_match_has_pattern_anchor(pattern));
  return (nelua_StrPatt_1){.source = source, .pattern = pattern, .plain = plain, .anchor = anchor, .depth = 32};
}
void nelua_StrPatt_1_reset_captures(nelua_StrPatt_1_ptr self) {
  for(intptr_t i = 0, _end = self->numcaptures; i < _end; i += 1) {
    self->capture[i] = (nelua_StrPattCapture){0};
  }
  self->numcaptures = 0;
}
nlmulret_nlboolean_nlstring_nelua_StrPattCapture nelua_StrPatt_1_get_capture(nelua_StrPatt_1_ptr self, intptr_t i) {
  if(NELUA_UNLIKELY(((i < 0) || (i >= self->numcaptures)))) {
    return (nlmulret_nlboolean_nlstring_nelua_StrPattCapture){false, ((nlstring){(uint8_t*)"invalid capture index", 21}), (nelua_StrPattCapture){0}};
  }
  if(NELUA_UNLIKELY(nelua_StrPattCapture_is_unfinished((&self->capture[i])))) {
    return (nlmulret_nlboolean_nlstring_nelua_StrPattCapture){false, ((nlstring){(uint8_t*)"unfinished capture", 18}), (nelua_StrPattCapture){0}};
  }
  nelua_StrPattCapture capture = self->capture[i];
  if((!nelua_StrPattCapture_is_position((&self->capture[i])))) {
    nlstring capstr = (nlstring){.data = ((nluint8_arr0_ptr)(&self->source.data[self->capture[i].init])), .size = (uintptr_t)self->capture[i].len};
    return (nlmulret_nlboolean_nlstring_nelua_StrPattCapture){true, capstr, capture};
  } else {
    return (nlmulret_nlboolean_nlstring_nelua_StrPattCapture){true, ((nlstring){(uint8_t*)"", 0}), capture};
  }
}
bool nelua_match_class(uint8_t c, uint8_t cl) {
  bool res = false;
  switch(cl) {
    case 97U: {
      res = nelua_strchar_1_isalpha(c);
      break;
    }
    case 65U: {
      res = (!nelua_strchar_1_isalpha(c));
      break;
    }
    case 99U: {
      res = nelua_strchar_1_iscntrl(c);
      break;
    }
    case 67U: {
      res = (!nelua_strchar_1_iscntrl(c));
      break;
    }
    case 100U: {
      res = nelua_strchar_1_isdigit(c);
      break;
    }
    case 68U: {
      res = (!nelua_strchar_1_isdigit(c));
      break;
    }
    case 103U: {
      res = nelua_strchar_1_isgraph(c);
      break;
    }
    case 71U: {
      res = (!nelua_strchar_1_isgraph(c));
      break;
    }
    case 108U: {
      res = nelua_strchar_1_islower(c);
      break;
    }
    case 76U: {
      res = (!nelua_strchar_1_islower(c));
      break;
    }
    case 112U: {
      res = nelua_strchar_1_ispunct(c);
      break;
    }
    case 80U: {
      res = (!nelua_strchar_1_ispunct(c));
      break;
    }
    case 115U: {
      res = nelua_strchar_1_isspace(c);
      break;
    }
    case 83U: {
      res = (!nelua_strchar_1_isspace(c));
      break;
    }
    case 117U: {
      res = nelua_strchar_1_isupper(c);
      break;
    }
    case 85U: {
      res = (!nelua_strchar_1_isupper(c));
      break;
    }
    case 119U: {
      res = nelua_strchar_1_isalnum(c);
      break;
    }
    case 87U: {
      res = (!nelua_strchar_1_isalnum(c));
      break;
    }
    case 120U: {
      res = nelua_strchar_1_isxdigit(c);
      break;
    }
    case 88U: {
      res = (!nelua_strchar_1_isxdigit(c));
      break;
    }
    case 122U: {
      res = (c == 0);
      break;
    }
    case 90U: {
      res = (c != 0);
      break;
    }
    default: {
      return (cl == c);
    }
  }
  return res;
}
intptr_t nelua_match_class_end(nelua_StrPatt_1_ptr ms_1, intptr_t p_1) {
  uint8_t c = ms_1->pattern.data[p_1];
  p_1 = (p_1 + 1);
  switch(c) {
    case 37U: {
      nelua_assert_msg_nlvoid((p_1 != nelua_nlstring___len(ms_1->pattern)), ((nlstring){(uint8_t*)"malformed pattern (ends with '%')", 33}));
      p_1 = (p_1 + 1);
      break;
    }
    case 91U: {
      if((ms_1->pattern.data[p_1] == 94U)) {
        p_1 = (p_1 + 1);
      }
      {
        bool _repeat_stop;
        do {
          nelua_assert_msg_nlvoid((p_1 != nelua_nlstring___len(ms_1->pattern)), ((nlstring){(uint8_t*)"malformed pattern (missing ']')", 31}));
          c = ms_1->pattern.data[p_1];
          p_1 = (p_1 + 1);
          if(((c == 37U) && (p_1 < nelua_nlstring___len(ms_1->pattern)))) {
            p_1 = (p_1 + 1);
          }
          _repeat_stop = (ms_1->pattern.data[p_1] == 93U);
        } while(!_repeat_stop);
      }
      p_1 = (p_1 + 1);
      break;
    }
  }
  return p_1;
}
bool nelua_match_bracket_class(nelua_StrPatt_1_ptr ms_2, uint8_t c, intptr_t p_2, intptr_t ep) {
  bool sig = true;
  if((ms_2->pattern.data[(p_2 + 1)] == 94U)) {
    sig = false;
    p_2 = (p_2 + 1);
  }
  p_2 = (p_2 + 1);
  while((p_2 < ep)) {
    if((ms_2->pattern.data[p_2] == 37U)) {
      p_2 = (p_2 + 1);
      if(nelua_match_class(c, ms_2->pattern.data[p_2])) {
        return sig;
      }
    } else if(((ms_2->pattern.data[(p_2 + 1)] == 45U) && ((p_2 + 2) < ep))) {
      p_2 = (p_2 + 2);
      if(((ms_2->pattern.data[(p_2 - 2)] <= c) && (c <= ms_2->pattern.data[p_2]))) {
        return sig;
      }
    } else if((ms_2->pattern.data[p_2] == c)) {
      return sig;
    }
    p_2 = (p_2 + 1);
  }
  return (!sig);
}
bool nelua_match_single(nelua_StrPatt_1_ptr ms_3, intptr_t s_1, intptr_t p_3, intptr_t ep) {
  if((s_1 >= nelua_nlstring___len(ms_3->source))) {
    return false;
  } else {
    uint8_t c = ms_3->source.data[s_1];
    uint8_t pc = ms_3->pattern.data[p_3];
    switch(pc) {
      case 46U: {
        return true;
      }
      case 37U: {
        return nelua_match_class(c, ms_3->pattern.data[(p_3 + 1)]);
      }
      case 91U: {
        return nelua_match_bracket_class(ms_3, c, p_3, (ep - 1));
      }
      default: {
        return (pc == c);
      }
    }
  }
}
intptr_t nelua_match_balance(nelua_StrPatt_1_ptr ms_4, intptr_t s_2, intptr_t p_4) {
  nelua_assert_msg_nlvoid((p_4 < (nelua_nlstring___len(ms_4->pattern) - 1)), ((nlstring){(uint8_t*)"malformed pattern (missing arguments to '%b')", 45}));
  if(((s_2 >= nelua_nlstring___len(ms_4->source)) || (ms_4->source.data[s_2] != ms_4->pattern.data[p_4]))) {
    return -1;
  } else {
    uint8_t b = ms_4->pattern.data[p_4];
    uint8_t e = ms_4->pattern.data[(p_4 + 1)];
    intptr_t cont = 1;
    s_2 = (s_2 + 1);
    while((s_2 < nelua_nlstring___len(ms_4->source))) {
      if((ms_4->source.data[s_2] == e)) {
        cont = (cont - 1);
        if((cont == 0)) {
          return (s_2 + 1);
        }
      } else if((ms_4->source.data[s_2] == b)) {
        cont = (cont + 1);
      }
      s_2 = (s_2 + 1);
    }
  }
  return -1;
}
intptr_t nelua_match_max_expand(nelua_StrPatt_1_ptr ms_5, intptr_t s_3, intptr_t p_5, intptr_t ep) {
  intptr_t i = 0;
  while(nelua_match_single(ms_5, (s_3 + i), p_5, ep)) {
    i = (i + 1);
  }
  while((i >= 0)) {
    intptr_t res = nelua_StrPatt_1__match(ms_5, (s_3 + i), (ep + 1));
    if((res != -1)) {
      return res;
    } else {
      i = (i - 1);
    }
  }
  return -1;
}
intptr_t nelua_match_min_expand(nelua_StrPatt_1_ptr ms_6, intptr_t s_4, intptr_t p_6, intptr_t ep) {
  while(true) {
    intptr_t res = nelua_StrPatt_1__match(ms_6, s_4, (ep + 1));
    if((res != -1)) {
      return res;
    } else if(nelua_match_single(ms_6, s_4, p_6, ep)) {
      s_4 = (s_4 + 1);
    } else {
      break;
    }
  }
  return -1;
}
intptr_t nelua_match_start_capture(nelua_StrPatt_1_ptr ms_7, intptr_t s_5, intptr_t p_7, intptr_t what) {
  intptr_t numcaptures = ms_7->numcaptures;
  nelua_assert_msg_nlvoid((numcaptures < 32), ((nlstring){(uint8_t*)"too many captures", 17}));
  ms_7->capture[numcaptures].init = s_5;
  ms_7->capture[numcaptures].len = what;
  ms_7->numcaptures = (numcaptures + 1);
  intptr_t res = nelua_StrPatt_1__match(ms_7, s_5, p_7);
  if((res == -1)) {
    ms_7->capture[numcaptures] = (nelua_StrPattCapture){0};
    ms_7->numcaptures = (ms_7->numcaptures - 1);
  }
  return res;
}
intptr_t nelua_match_end_capture(nelua_StrPatt_1_ptr ms_8, intptr_t s_6, intptr_t p_8) {
  intptr_t l = -1;
  for(intptr_t numcaptures = (ms_8->numcaptures - 1); numcaptures >= 0; numcaptures += -1) {
    if((ms_8->capture[numcaptures].len == -1)) {
      l = numcaptures;
      break;
    }
  }
  nelua_assert_msg_nlvoid((l != -1), ((nlstring){(uint8_t*)"invalid pattern capture", 23}));
  ms_8->capture[l].len = (s_6 - ms_8->capture[l].init);
  intptr_t res = nelua_StrPatt_1__match(ms_8, s_6, p_8);
  if((res == -1)) {
    ms_8->capture[l].len = -1;
  }
  return res;
}
intptr_t nelua_match_capture(nelua_StrPatt_1_ptr ms_9, intptr_t s_7, intptr_t l) {
  l = (intptr_t)(l - 49U);
  nelua_assert_msg_nlvoid((((l >= 0) && (l < ms_9->numcaptures)) && (ms_9->capture[l].len != -1)), ((nlstring){(uint8_t*)"invalid capture index", 21}));
  uintptr_t len = (uintptr_t)ms_9->capture[l].len;
  if((((uintptr_t)(nelua_nlstring___len(ms_9->source) - s_7) >= len) && (nelua_memory_compare((void*)(&ms_9->source.data[ms_9->capture[l].init]), (void*)(&ms_9->source.data[s_7]), len) == 0))) {
    return (intptr_t)(int64_t)(s_7 + len);
  }
  return -1;
}
intptr_t nelua_StrPatt_1__match(nelua_StrPatt_1_ptr ms, intptr_t s, intptr_t p) {
  ms->depth = (ms->depth - 1);
  nelua_assert_msg_nlvoid((ms->depth > 0), ((nlstring){(uint8_t*)"pattern too complex", 19}));
  while((p < nelua_nlstring___len(ms->pattern))) {
    switch(ms->pattern.data[p]) {
      case 40U: {
        if((ms->pattern.data[(p + 1)] == 41U)) {
          s = nelua_match_start_capture(ms, s, (p + 2), -2);
        } else {
          s = nelua_match_start_capture(ms, s, (p + 1), -1);
        }
        goto _breaklabel_1;
      }
      case 41U: {
        s = nelua_match_end_capture(ms, s, (p + 1));
        goto _breaklabel_1;
      }
      case 36U: {
        if(((p + 1) == nelua_nlstring___len(ms->pattern))) {
          if((s != nelua_nlstring___len(ms->source))) {
            s = -1;
          }
          goto _breaklabel_1;
        }
        break;
      }
      case 37U: {
        switch(ms->pattern.data[(p + 1)]) {
          case 98U: {
            s = nelua_match_balance(ms, s, (p + 2));
            if((s != -1)) {
              p = (p + 4);
              continue;
            }
            goto _breaklabel_1;
          }
          case 102U: {
            p = (p + 2);
            nelua_assert_msg_nlvoid((ms->pattern.data[p] == 91U), ((nlstring){(uint8_t*)"missing '[' after '%f' in pattern", 33}));
            intptr_t ep = nelua_match_class_end(ms, p);
            uint8_t previous = (((s == 0) && (s < nelua_nlstring___len(ms->source))) ? 0x0U : ms->source.data[(s - 1)]);
            uint8_t next_1 = ((s == nelua_nlstring___len(ms->source)) ? 0x0U : ms->source.data[s]);
            if(((!nelua_match_bracket_class(ms, previous, p, (ep - 1))) && nelua_match_bracket_class(ms, next_1, p, (ep - 1)))) {
              p = ep;
              continue;
            }
            s = -1;
            goto _breaklabel_1;
          }
          case 48U:
          case 49U:
          case 50U:
          case 51U:
          case 52U:
          case 53U:
          case 54U:
          case 55U:
          case 56U:
          case 57U: {
            s = nelua_match_capture(ms, s, (intptr_t)ms->pattern.data[(p + 1)]);
            if((s != -1)) {
              p = (p + 2);
              continue;
            }
            goto _breaklabel_1;
          }
        }
        break;
      }
    }
    {
      intptr_t ep = nelua_match_class_end(ms, p);
      uint8_t epc = ms->pattern.data[ep];
      if((!nelua_match_single(ms, s, p, ep))) {
        if((((epc == 42U) || (epc == 63U)) || (epc == 45U))) {
          p = (ep + 1);
          continue;
        } else {
          s = -1;
        }
      } else {
        switch(epc) {
          case 63U: {
            intptr_t res = nelua_StrPatt_1__match(ms, (s + 1), (ep + 1));
            if((res != -1)) {
              s = res;
            } else {
              p = (ep + 1);
              continue;
            }
            break;
          }
          case 43U: {
            s = (s + 1);
            s = nelua_match_max_expand(ms, s, p, ep);
            break;
          }
          case 42U: {
            s = nelua_match_max_expand(ms, s, p, ep);
            break;
          }
          case 45U: {
            s = nelua_match_min_expand(ms, s, p, ep);
            break;
          }
          default: {
            s = (s + 1);
            p = ep;
            continue;
          }
        }
      }
      break;
    }
  }
  _breaklabel_1:;
  ms->depth = (ms->depth + 1);
  return s;
}
nlmulret_nlisize_nlisize nelua_StrPatt_1_match(nelua_StrPatt_1_ptr ms, intptr_t s) {
  if(((uintptr_t)s > ms->source.size)) {
    return (nlmulret_nlisize_nlisize){s, -1};
  } else if((ms->pattern.size == 0)) {
    return (nlmulret_nlisize_nlisize){s, s};
  } else if(ms->plain) {
    void* found = nelua_memory_find((void*)(&ms->source.data[s]), (ms->source.size - (uintptr_t)s), (void*)(&ms->pattern.data[0]), ms->pattern.size);
    if((!(found != NULL))) {
      return (nlmulret_nlisize_nlisize){s, -1};
    } else {
      s = (intptr_t)((uintptr_t)found - (uintptr_t)(&ms->source.data[0]));
      return (nlmulret_nlisize_nlisize){s, (intptr_t)(int64_t)(s + ms->pattern.size)};
    }
  } else {
    intptr_t p = 0;
    if(ms->anchor) {
      p = 1;
    }
    {
      bool _repeat_stop;
      do {
        nelua_StrPatt_1_reset_captures(ms);
        intptr_t e = nelua_StrPatt_1__match(ms, s, p);
        if((e != -1)) {
          return (nlmulret_nlisize_nlisize){s, e};
        }
        s = (s + 1);
        _repeat_stop = ((s > nelua_nlstring___len(ms->source)) || ms->anchor);
      } while(!_repeat_stop);
    }
    return (nlmulret_nlisize_nlisize){s, -1};
  }
}
nlmulret_nlisize_nlisize nelua_nlstring_find_1(nlstring s, nlstring pattern, intptr_t init, bool plain) {
  if((init < 0)) {
    init = (((intptr_t)s.size + init) + 1);
  }
  if((init <= 0)) {
    init = 1;
  }
  nelua_StrPatt_1 ms = nelua_StrPatt_1_create(s, pattern, plain);
  nlmulret_nlisize_nlisize _asgnret_1 = nelua_StrPatt_1_match((&ms), (init - 1));
  intptr_t startpos = _asgnret_1.r1;
  intptr_t endpos = _asgnret_1.r2;
  if((endpos != -1)) {
    return (nlmulret_nlisize_nlisize){(startpos + 1), endpos};
  } else {
    return (nlmulret_nlisize_nlisize){0, 0};
  }
}
bool nelua_lt_nlisize_nlusize(intptr_t a, uintptr_t b) {
  return a < 0 || (uint64_t)a < b;
}
nlmulret_nlstring_nlisize nelua_nlstring_gsub_1(nlstring s, nlstring pattern, nlstring repl, nlniltype maxn) {
  intptr_t maxn_1 = ((intptr_t)s.size + 1);
  intptr_t n = 0;
  nelua_stringbuilderT sb = (nelua_stringbuilderT){0};
  intptr_t pos = 0;
  nelua_StrPatt_1 ms = nelua_StrPatt_1_create(s, pattern, false);
  intptr_t lastmatch = -1;
  while((n < maxn_1)) {
    nlmulret_nlisize_nlisize _asgnret_1 = nelua_StrPatt_1_match((&ms), pos);
    intptr_t startpos = _asgnret_1.r1;
    intptr_t endpos = _asgnret_1.r2;
    if(((endpos != -1) && (endpos != lastmatch))) {
      lastmatch = endpos;
      n = (n + 1);
      nlstring skip = (nlstring){.data = ((nluint8_arr0_ptr)(&s.data[pos])), .size = (uintptr_t)(startpos - pos)};
      nelua_stringbuilderT_write_1((&sb), skip);
      nlstring match = (nlstring){.data = ((nluint8_arr0_ptr)(&s.data[startpos])), .size = (uintptr_t)(endpos - startpos)};
      nlstring matchrepl = (nlstring){0};
      uintptr_t ri = 0U;
      matchrepl = repl;
      while(true) {
        void* found = nelua_memory_scan((void*)(&matchrepl.data[ri]), 37U, (matchrepl.size - ri));
        if((!(found != NULL))) {
          break;
        }
        uintptr_t advance = ((uintptr_t)found - (uintptr_t)(&matchrepl.data[ri]));
        nelua_stringbuilderT_write_1((&sb), (nlstring){((nluint8_arr0_ptr)(&matchrepl.data[ri])), advance});
        uint8_t c = matchrepl.data[((ri + advance) + 1)];
        if((c == 37U)) {
          nelua_stringbuilderT_writebyte_1((&sb), 37U, NELUA_NIL);
        } else if((c == 48U)) {
          nelua_stringbuilderT_write_1((&sb), match);
        } else if(((c >= 49U) && (c <= 57U))) {
          intptr_t capindex = (intptr_t)(c - 49U);
          nlmulret_nlboolean_nlstring_nelua_StrPattCapture _asgnret_2 = nelua_StrPatt_1_get_capture((&ms), capindex);
          bool ok = _asgnret_2.r1;
          nlstring capstr = _asgnret_2.r2;
          nelua_StrPattCapture capture = _asgnret_2.r3;
          if((((!ok) && (capindex == 0)) && (ms.numcaptures == 0))) {
            nelua_stringbuilderT_write_1((&sb), match);
          } else {
            nelua_assert_msg_nlvoid(ok, capstr);
            if(nelua_StrPattCapture_is_position((&capture))) {
              nlstring s_8 = nelua_tostring_3((capture.init + 1));
              nelua_stringbuilderT_write_1((&sb), s_8);
              nelua_nlstring_destroy((&s_8));
            } else {
              nelua_stringbuilderT_write_1((&sb), capstr);
            }
          }
        } else {
          nelua_panic_string(((nlstring){(uint8_t*)"invalid use of '%' in replacement string", 40}));
        }
        ri = ((ri + advance) + 2);
      }
      nelua_stringbuilderT_write_1((&sb), (nlstring){((nluint8_arr0_ptr)(&matchrepl.data[ri])), (matchrepl.size - ri)});
      pos = endpos;
    } else if(nelua_lt_nlisize_nlusize(pos, s.size)) {
      nelua_stringbuilderT_writebyte_1((&sb), s.data[pos], NELUA_NIL);
      pos = (pos + 1);
    } else {
      break;
    }
    if(ms.anchor) {
      break;
    }
  }
  nelua_stringbuilderT_write_1((&sb), (nlstring){((nluint8_arr0_ptr)(&s.data[pos])), (uintptr_t)(int64_t)(s.size - pos)});
  nlmulret_nlstring_nlisize _mulret_1;
  _mulret_1.r1 = nelua_stringbuilderT_promote((&sb));
  _mulret_1.r2 = n;
  return _mulret_1;
}
nlstring nelua_tostring_3(intptr_t x) {
  nluint8_arr48 buf;
  nlstring s = nelua_strconv_1_int2str_2((&buf), x, NELUA_NIL);
  return nelua_nlstring_copy(s);
}
nlstring nelua_tostring_4(int64_t x) {
  nluint8_arr48 buf;
  nlstring s = nelua_strconv_1_int2str_2((&buf), (intptr_t)x, NELUA_NIL);
  return nelua_nlstring_copy(s);
}
nlstring nelua_tostring_5(int x) {
  nluint8_arr48 buf;
  nlstring s = nelua_strconv_1_int2str_2((&buf), (intptr_t)x, NELUA_NIL);
  return nelua_nlstring_copy(s);
}
int64_t nelua_tointeger_1(nlstring x, nlniltype base) {
  nlmulret_nlboolean_nlint64 _asgnret_1 = nelua_strconv_1_str2int(x, 0U);
  bool ok = _asgnret_1.r1;
  int64_t i = _asgnret_1.r2;
  nelua_assert_msg_nlvoid(ok, ((nlstring){(uint8_t*)"malformed integer", 17}));
  return i;
}
FILE_ptr nelua_filestream__getfp(nelua_filestream_ptr self) {
  if((!(self->fs != NULL))) {
    return ((FILE_ptr)NULL);
  }
  return self->fs->fp;
}
nlstring nelua_cstring2string(const char* s) {
  if(s == NULL) {
    return (nlstring){0};
  }
  uintptr_t size = strlen(s);
  if(size == 0) {
    return (nlstring){0};
  }
  return (nlstring){(uint8_t*)s, size};
}
nlmulret_nlstring_nlint64 nelua_geterrno(void) {
  return (nlmulret_nlstring_nlint64){nelua_cstring2string(strerror(errno)), (int64_t)errno};
}
nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_flush(nelua_filestream_ptr self) {
  FILE_ptr fp = nelua_filestream__getfp(self);
  if((!(fp != NULL))) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  if((fflush(fp) != 0)) {
    nlmulret_nlstring_nlint64 _ret_1 = nelua_geterrno();
    return (nlmulret_nlboolean_nlstring_nlint64){false, _ret_1.r1, _ret_1.r2};
  }
  return (nlmulret_nlboolean_nlstring_nlint64){true, (nlstring){0}, 0};
}
nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_write_1(nelua_filestream_ptr self, nlstring __arg1) {
  FILE_ptr fp = nelua_filestream__getfp(self);
  if((!(fp != NULL))) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  {
    nlstring s = __arg1;
    if((s.size > 0)) {
      bool ok = (fwrite((void*)s.data, 1U, (size_t)s.size, fp) == s.size);
      if((!ok)) {
        nlmulret_nlstring_nlint64 _ret_1 = nelua_geterrno();
        return (nlmulret_nlboolean_nlstring_nlint64){false, _ret_1.r1, _ret_1.r2};
      }
    }
  }
  return (nlmulret_nlboolean_nlstring_nlint64){true, ((nlstring){(uint8_t*)"", 0}), 0};
}
nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_writef_1(nelua_filestream_ptr self, nlstring fmt, int64_t __arg1, int64_t __arg2) {
  FILE_ptr fp = nelua_filestream__getfp(self);
  if((!(fp != NULL))) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  nelua_stringbuilderT sb = (nelua_stringbuilderT){0};
  if((!nelua_stringbuilderT_writef_3((&sb), fmt, __arg1, __arg2).r1)) {
    nlmulret_nlboolean_nlstring_nlint64 _mulret_1;
    _mulret_1.r1 = false;
    _mulret_1.r2 = ((nlstring){(uint8_t*)"not enough memory", 17});
    _mulret_1.r3 = 0;
    { /* defer */
      nelua_stringbuilderT_destroy((&sb));
    }
    return _mulret_1;
  }
  nlstring s = nelua_stringbuilderT_view((&sb));
  if((s.size > 0)) {
    size_t res = fwrite((void*)s.data, 1U, (size_t)s.size, fp);
    if((res != s.size)) {
      nlmulret_nlboolean_nlstring_nlint64 _mulret_2;
      _mulret_2.r1 = false;
      nlmulret_nlstring_nlint64 _ret_1 = nelua_geterrno();
      _mulret_2.r2 = _ret_1.r1;
      _mulret_2.r3 = _ret_1.r2;
      { /* defer */
        nelua_stringbuilderT_destroy((&sb));
      }
      return _mulret_2;
    }
  }
  nlmulret_nlboolean_nlstring_nlint64 _mulret_3;
  _mulret_3.r1 = true;
  _mulret_3.r2 = ((nlstring){(uint8_t*)"", 0});
  _mulret_3.r3 = 0;
  { /* defer */
    nelua_stringbuilderT_destroy((&sb));
  }
  return _mulret_3;
}
nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_writef_2(nelua_filestream_ptr self, nlstring fmt, nlstring __arg1, int __arg2, int64_t __arg3, int64_t __arg4) {
  FILE_ptr fp = nelua_filestream__getfp(self);
  if((!(fp != NULL))) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  nelua_stringbuilderT sb = (nelua_stringbuilderT){0};
  if((!nelua_stringbuilderT_writef_4((&sb), fmt, __arg1, __arg2, __arg3, __arg4).r1)) {
    nlmulret_nlboolean_nlstring_nlint64 _mulret_1;
    _mulret_1.r1 = false;
    _mulret_1.r2 = ((nlstring){(uint8_t*)"not enough memory", 17});
    _mulret_1.r3 = 0;
    { /* defer */
      nelua_stringbuilderT_destroy((&sb));
    }
    return _mulret_1;
  }
  nlstring s = nelua_stringbuilderT_view((&sb));
  if((s.size > 0)) {
    size_t res = fwrite((void*)s.data, 1U, (size_t)s.size, fp);
    if((res != s.size)) {
      nlmulret_nlboolean_nlstring_nlint64 _mulret_2;
      _mulret_2.r1 = false;
      nlmulret_nlstring_nlint64 _ret_1 = nelua_geterrno();
      _mulret_2.r2 = _ret_1.r1;
      _mulret_2.r3 = _ret_1.r2;
      { /* defer */
        nelua_stringbuilderT_destroy((&sb));
      }
      return _mulret_2;
    }
  }
  nlmulret_nlboolean_nlstring_nlint64 _mulret_3;
  _mulret_3.r1 = true;
  _mulret_3.r2 = ((nlstring){(uint8_t*)"", 0});
  _mulret_3.r3 = 0;
  { /* defer */
    nelua_stringbuilderT_destroy((&sb));
  }
  return _mulret_3;
}
nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_writef_3(nelua_filestream_ptr self, nlstring fmt) {
  FILE_ptr fp = nelua_filestream__getfp(self);
  if((!(fp != NULL))) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  nelua_stringbuilderT sb = (nelua_stringbuilderT){0};
  if((!nelua_stringbuilderT_writef_5((&sb), fmt).r1)) {
    nlmulret_nlboolean_nlstring_nlint64 _mulret_1;
    _mulret_1.r1 = false;
    _mulret_1.r2 = ((nlstring){(uint8_t*)"not enough memory", 17});
    _mulret_1.r3 = 0;
    { /* defer */
      nelua_stringbuilderT_destroy((&sb));
    }
    return _mulret_1;
  }
  nlstring s = nelua_stringbuilderT_view((&sb));
  if((s.size > 0)) {
    size_t res = fwrite((void*)s.data, 1U, (size_t)s.size, fp);
    if((res != s.size)) {
      nlmulret_nlboolean_nlstring_nlint64 _mulret_2;
      _mulret_2.r1 = false;
      nlmulret_nlstring_nlint64 _ret_1 = nelua_geterrno();
      _mulret_2.r2 = _ret_1.r1;
      _mulret_2.r3 = _ret_1.r2;
      { /* defer */
        nelua_stringbuilderT_destroy((&sb));
      }
      return _mulret_2;
    }
  }
  nlmulret_nlboolean_nlstring_nlint64 _mulret_3;
  _mulret_3.r1 = true;
  _mulret_3.r2 = ((nlstring){(uint8_t*)"", 0});
  _mulret_3.r3 = 0;
  { /* defer */
    nelua_stringbuilderT_destroy((&sb));
  }
  return _mulret_3;
}
nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_writef_4(nelua_filestream_ptr self, nlstring fmt, int __arg1) {
  FILE_ptr fp = nelua_filestream__getfp(self);
  if((!(fp != NULL))) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  nelua_stringbuilderT sb = (nelua_stringbuilderT){0};
  if((!nelua_stringbuilderT_writef_2((&sb), fmt, __arg1).r1)) {
    nlmulret_nlboolean_nlstring_nlint64 _mulret_1;
    _mulret_1.r1 = false;
    _mulret_1.r2 = ((nlstring){(uint8_t*)"not enough memory", 17});
    _mulret_1.r3 = 0;
    { /* defer */
      nelua_stringbuilderT_destroy((&sb));
    }
    return _mulret_1;
  }
  nlstring s = nelua_stringbuilderT_view((&sb));
  if((s.size > 0)) {
    size_t res = fwrite((void*)s.data, 1U, (size_t)s.size, fp);
    if((res != s.size)) {
      nlmulret_nlboolean_nlstring_nlint64 _mulret_2;
      _mulret_2.r1 = false;
      nlmulret_nlstring_nlint64 _ret_1 = nelua_geterrno();
      _mulret_2.r2 = _ret_1.r1;
      _mulret_2.r3 = _ret_1.r2;
      { /* defer */
        nelua_stringbuilderT_destroy((&sb));
      }
      return _mulret_2;
    }
  }
  nlmulret_nlboolean_nlstring_nlint64 _mulret_3;
  _mulret_3.r1 = true;
  _mulret_3.r2 = ((nlstring){(uint8_t*)"", 0});
  _mulret_3.r3 = 0;
  { /* defer */
    nelua_stringbuilderT_destroy((&sb));
  }
  return _mulret_3;
}
nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_writef_5(nelua_filestream_ptr self, nlstring fmt, nlstring __arg1, nlstring __arg2) {
  FILE_ptr fp = nelua_filestream__getfp(self);
  if((!(fp != NULL))) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  nelua_stringbuilderT sb = (nelua_stringbuilderT){0};
  if((!nelua_stringbuilderT_writef_6((&sb), fmt, __arg1, __arg2).r1)) {
    nlmulret_nlboolean_nlstring_nlint64 _mulret_1;
    _mulret_1.r1 = false;
    _mulret_1.r2 = ((nlstring){(uint8_t*)"not enough memory", 17});
    _mulret_1.r3 = 0;
    { /* defer */
      nelua_stringbuilderT_destroy((&sb));
    }
    return _mulret_1;
  }
  nlstring s = nelua_stringbuilderT_view((&sb));
  if((s.size > 0)) {
    size_t res = fwrite((void*)s.data, 1U, (size_t)s.size, fp);
    if((res != s.size)) {
      nlmulret_nlboolean_nlstring_nlint64 _mulret_2;
      _mulret_2.r1 = false;
      nlmulret_nlstring_nlint64 _ret_1 = nelua_geterrno();
      _mulret_2.r2 = _ret_1.r1;
      _mulret_2.r3 = _ret_1.r2;
      { /* defer */
        nelua_stringbuilderT_destroy((&sb));
      }
      return _mulret_2;
    }
  }
  nlmulret_nlboolean_nlstring_nlint64 _mulret_3;
  _mulret_3.r1 = true;
  _mulret_3.r2 = ((nlstring){(uint8_t*)"", 0});
  _mulret_3.r3 = 0;
  { /* defer */
    nelua_stringbuilderT_destroy((&sb));
  }
  return _mulret_3;
}
nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_writef_6(nelua_filestream_ptr self, nlstring fmt, int __arg1, nlstring __arg2, nlstring __arg3) {
  FILE_ptr fp = nelua_filestream__getfp(self);
  if((!(fp != NULL))) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  nelua_stringbuilderT sb = (nelua_stringbuilderT){0};
  if((!nelua_stringbuilderT_writef_7((&sb), fmt, __arg1, __arg2, __arg3).r1)) {
    nlmulret_nlboolean_nlstring_nlint64 _mulret_1;
    _mulret_1.r1 = false;
    _mulret_1.r2 = ((nlstring){(uint8_t*)"not enough memory", 17});
    _mulret_1.r3 = 0;
    { /* defer */
      nelua_stringbuilderT_destroy((&sb));
    }
    return _mulret_1;
  }
  nlstring s = nelua_stringbuilderT_view((&sb));
  if((s.size > 0)) {
    size_t res = fwrite((void*)s.data, 1U, (size_t)s.size, fp);
    if((res != s.size)) {
      nlmulret_nlboolean_nlstring_nlint64 _mulret_2;
      _mulret_2.r1 = false;
      nlmulret_nlstring_nlint64 _ret_1 = nelua_geterrno();
      _mulret_2.r2 = _ret_1.r1;
      _mulret_2.r3 = _ret_1.r2;
      { /* defer */
        nelua_stringbuilderT_destroy((&sb));
      }
      return _mulret_2;
    }
  }
  nlmulret_nlboolean_nlstring_nlint64 _mulret_3;
  _mulret_3.r1 = true;
  _mulret_3.r2 = ((nlstring){(uint8_t*)"", 0});
  _mulret_3.r3 = 0;
  { /* defer */
    nelua_stringbuilderT_destroy((&sb));
  }
  return _mulret_3;
}
nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_writef_7(nelua_filestream_ptr self, nlstring fmt, nlstring __arg1) {
  FILE_ptr fp = nelua_filestream__getfp(self);
  if((!(fp != NULL))) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  nelua_stringbuilderT sb = (nelua_stringbuilderT){0};
  if((!nelua_stringbuilderT_writef_8((&sb), fmt, __arg1).r1)) {
    nlmulret_nlboolean_nlstring_nlint64 _mulret_1;
    _mulret_1.r1 = false;
    _mulret_1.r2 = ((nlstring){(uint8_t*)"not enough memory", 17});
    _mulret_1.r3 = 0;
    { /* defer */
      nelua_stringbuilderT_destroy((&sb));
    }
    return _mulret_1;
  }
  nlstring s = nelua_stringbuilderT_view((&sb));
  if((s.size > 0)) {
    size_t res = fwrite((void*)s.data, 1U, (size_t)s.size, fp);
    if((res != s.size)) {
      nlmulret_nlboolean_nlstring_nlint64 _mulret_2;
      _mulret_2.r1 = false;
      nlmulret_nlstring_nlint64 _ret_1 = nelua_geterrno();
      _mulret_2.r2 = _ret_1.r1;
      _mulret_2.r3 = _ret_1.r2;
      { /* defer */
        nelua_stringbuilderT_destroy((&sb));
      }
      return _mulret_2;
    }
  }
  nlmulret_nlboolean_nlstring_nlint64 _mulret_3;
  _mulret_3.r1 = true;
  _mulret_3.r2 = ((nlstring){(uint8_t*)"", 0});
  _mulret_3.r3 = 0;
  { /* defer */
    nelua_stringbuilderT_destroy((&sb));
  }
  return _mulret_3;
}
nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_writef_8(nelua_filestream_ptr self, nlstring fmt, nlstring __arg1, nlstring __arg2, nlstring __arg3) {
  FILE_ptr fp = nelua_filestream__getfp(self);
  if((!(fp != NULL))) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  nelua_stringbuilderT sb = (nelua_stringbuilderT){0};
  if((!nelua_stringbuilderT_writef_9((&sb), fmt, __arg1, __arg2, __arg3).r1)) {
    nlmulret_nlboolean_nlstring_nlint64 _mulret_1;
    _mulret_1.r1 = false;
    _mulret_1.r2 = ((nlstring){(uint8_t*)"not enough memory", 17});
    _mulret_1.r3 = 0;
    { /* defer */
      nelua_stringbuilderT_destroy((&sb));
    }
    return _mulret_1;
  }
  nlstring s = nelua_stringbuilderT_view((&sb));
  if((s.size > 0)) {
    size_t res = fwrite((void*)s.data, 1U, (size_t)s.size, fp);
    if((res != s.size)) {
      nlmulret_nlboolean_nlstring_nlint64 _mulret_2;
      _mulret_2.r1 = false;
      nlmulret_nlstring_nlint64 _ret_1 = nelua_geterrno();
      _mulret_2.r2 = _ret_1.r1;
      _mulret_2.r3 = _ret_1.r2;
      { /* defer */
        nelua_stringbuilderT_destroy((&sb));
      }
      return _mulret_2;
    }
  }
  nlmulret_nlboolean_nlstring_nlint64 _mulret_3;
  _mulret_3.r1 = true;
  _mulret_3.r2 = ((nlstring){(uint8_t*)"", 0});
  _mulret_3.r3 = 0;
  { /* defer */
    nelua_stringbuilderT_destroy((&sb));
  }
  return _mulret_3;
}
nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_writef_9(nelua_filestream_ptr self, nlstring fmt, nlstring __arg1, int64_t __arg2) {
  FILE_ptr fp = nelua_filestream__getfp(self);
  if((!(fp != NULL))) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  nelua_stringbuilderT sb = (nelua_stringbuilderT){0};
  if((!nelua_stringbuilderT_writef_10((&sb), fmt, __arg1, __arg2).r1)) {
    nlmulret_nlboolean_nlstring_nlint64 _mulret_1;
    _mulret_1.r1 = false;
    _mulret_1.r2 = ((nlstring){(uint8_t*)"not enough memory", 17});
    _mulret_1.r3 = 0;
    { /* defer */
      nelua_stringbuilderT_destroy((&sb));
    }
    return _mulret_1;
  }
  nlstring s = nelua_stringbuilderT_view((&sb));
  if((s.size > 0)) {
    size_t res = fwrite((void*)s.data, 1U, (size_t)s.size, fp);
    if((res != s.size)) {
      nlmulret_nlboolean_nlstring_nlint64 _mulret_2;
      _mulret_2.r1 = false;
      nlmulret_nlstring_nlint64 _ret_1 = nelua_geterrno();
      _mulret_2.r2 = _ret_1.r1;
      _mulret_2.r3 = _ret_1.r2;
      { /* defer */
        nelua_stringbuilderT_destroy((&sb));
      }
      return _mulret_2;
    }
  }
  nlmulret_nlboolean_nlstring_nlint64 _mulret_3;
  _mulret_3.r1 = true;
  _mulret_3.r2 = ((nlstring){(uint8_t*)"", 0});
  _mulret_3.r3 = 0;
  { /* defer */
    nelua_stringbuilderT_destroy((&sb));
  }
  return _mulret_3;
}
void nelua_filestream_printf_1(nelua_filestream_ptr self, nlstring __arg1, int64_t __arg2, int64_t __arg3) {
  nelua_filestream_writef_1(self, __arg1, __arg2, __arg3);
  nelua_filestream_flush(self);
}
void nelua_filestream_printf_2(nelua_filestream_ptr self, nlstring __arg1, nlstring __arg2, int __arg3, int64_t __arg4, int64_t __arg5) {
  nelua_filestream_writef_2(self, __arg1, __arg2, __arg3, __arg4, __arg5);
  nelua_filestream_flush(self);
}
nltype nelua_require_io(nlniltype modname) {
  nelua_stdoutfs = (nelua_FStream){.fp = stdout};
  nelua_io_stdout = (nelua_filestream){.fs = (&nelua_stdoutfs)};
  nelua_stderrfs = (nelua_FStream){.fp = stderr};
  nelua_io_stderr = (nelua_filestream){.fs = (&nelua_stderrfs)};
  return NELUA_NIL;
}
double nelua_os_now(void) {
  bool ok = false;
  int64_t ns = 0;
#if defined(_WIN32)
  static bool initialized = false;
  static LARGE_INTEGER freq;
  static LARGE_INTEGER start;
  if(!initialized) {
    initialized = true;
    ok = (QueryPerformanceFrequency(&freq) != 0) && (QueryPerformanceCounter(&start) != 0);
  } else {
    LARGE_INTEGER qpc;
    ok = QueryPerformanceCounter(&qpc) != 0;
    int64_t ticks = qpc.QuadPart - start.QuadPart;
    int64_t q = ticks / freq.QuadPart;
    int64_t r = ticks % freq.QuadPart;
    ns = (q * 1000000000) + ((r * 1000000000) / freq.QuadPart);
  }
#elif defined(NELUA_HAVE_POSIX_MONOTONIC_CLOCK)
  static bool initialized = false;
  static struct timespec start = {0};
  if(!initialized) {
    initialized = true;
    ok = clock_gettime(CLOCK_MONOTONIC, &start) == 0;
  } else {
    struct timespec ts = {0};
    ok = clock_gettime(CLOCK_MONOTONIC, &ts) == 0;
    ns = (int64_t)(ts.tv_sec - start.tv_sec)*1000000000 + (int64_t)(ts.tv_nsec - start.tv_nsec);
  }
#elif defined(NELUA_HAVE_C11_TIMESPEC_GET)
  static bool initialized = false;
  static struct timespec start = {0};
  if(!initialized) {
    initialized = true;
    ok = timespec_get(&start, TIME_UTC) == TIME_UTC;
  } else {
    struct timespec ts = {0};
    ok = timespec_get(&ts, TIME_UTC) == TIME_UTC;
    ns = (int64_t)(ts.tv_sec - start.tv_sec)*1000000000 + (int64_t)(ts.tv_nsec - start.tv_nsec);
  }
#elif defined(NELUA_HAVE_POSIX_GETTIMEOFDAY)
  static bool initialized = false;
  static struct timeval start = {0};
  if(!initialized) {
    initialized = true;
    ok = gettimeofday(&start, NULL) == 0;
  } else {
    struct timeval ts;
    ok = gettimeofday(&ts, NULL) == 0;
    ns = (int64_t)(ts.tv_sec - start.tv_sec)*1000000000 + (int64_t)(ts.tv_usec - start.tv_usec)*1000;
  }
#endif
  if((!ok)) {
    return -1.0;
  }
  return (ns / 1000000000.0);
}
int64_t nelua_math_min_1(int64_t __arg1, int64_t __arg2) {
  return ((__arg1 < __arg2) ? __arg1 : __arg2);
}
int64_t nelua_math_max_1(int64_t __arg1, int64_t __arg2) {
  return ((__arg2 < __arg1) ? __arg1 : __arg2);
}
nelua_sequence_string__1 nelua_require_arg(nlniltype modname) {
  if((nelua_argc > 0)) {
    uintptr_t narg = (uintptr_t)(nelua_argc - 1);
    nelua_sequence_string__1_reserve((&nelua_arg), narg);
    for(uintptr_t i = 0U, _end = narg; i <= _end; i += 1) {
      (*nelua_sequence_string__1___atindex((&nelua_arg), i)) = nelua_cstring2string(nelua_argv[i]);
    }
  }
  return nelua_arg;
}
uintptr_t nelua_lhash(nluint8_arr0_ptr data, uintptr_t len, uintptr_t seed, uintptr_t step) {
  seed = (seed ^ len);
  while((len >= step)) {
    seed = (seed ^ (((seed << 5) + (seed >> 2)) + data[(len - 1)]));
    len = (len - step);
  }
  return seed;
}
uintptr_t nelua_hash_long(nelua_span_uint8_ data) {
  return nelua_lhash(data.data, data.size, 0x9e3779b9ULL, ((data.size >> 5) + 1));
}
uintptr_t nelua_hash_hash_1(nlstring v) {
  return nelua_hash_long((nelua_span_uint8_){.data = v.data, .size = v.size});
}
uintptr_t nelua_ceilidiv(uintptr_t x, uintptr_t y) {
  return (((x + y) - 1) / y);
}
uintptr_t nelua_hashmod(uintptr_t h, uintptr_t n) {
  return (h & (n - 1));
}
uintptr_t nelua_roundpow2(uintptr_t n) {
  if(((n & (n - 1)) == 0)) {
    return n;
  }
  n = (n | (n >> 1));
  n = (n | (n >> 2));
  n = (n | (n >> 4));
  n = (n | (n >> 8));
  n = (n | (n >> 16));
  n = (n | (n >> 32));
  n = (n + 1);
  return n;
}
nlmulret_nlusize_nlusize_nlusize nelua_hashmap_string__cint___find(nelua_hashmap_string__cint__ptr self, nlstring key) {
  uintptr_t h = nelua_hash_hash_1(key);
  uintptr_t buckets_size = self->buckets.size;
  uintptr_t bucket_index = nelua_hashmod(h, buckets_size);
  uintptr_t prev_node_index = 0xffffffffffffffffULL;
  if(NELUA_UNLIKELY((buckets_size == 0))) {
    return (nlmulret_nlusize_nlusize_nlusize){0xffffffffffffffffULL, prev_node_index, bucket_index};
  }
  uintptr_t node_index = (*nelua_span_usize____atindex(self->buckets, bucket_index));
  while((node_index != 0xffffffffffffffffULL)) {
    nelua_hashmapnode_string__cint__ptr node = (&(*nelua_span_hashmapnode_string__cint_____atindex(self->nodes, node_index)));
    bool eq = nelua_nlstring___eq(key, node->key);
    if(eq) {
      return (nlmulret_nlusize_nlusize_nlusize){node_index, prev_node_index, bucket_index};
    }
    prev_node_index = node_index;
    node_index = node->next;
  }
  return (nlmulret_nlusize_nlusize_nlusize){node_index, prev_node_index, bucket_index};
}
void nelua_hashmap_string__cint__rehash(nelua_hashmap_string__cint__ptr self, uintptr_t bucket_count) {
  uintptr_t min_buckets_count = nelua_ceilidiv((self->size * 100), 75U);
  if((bucket_count < min_buckets_count)) {
    bucket_count = min_buckets_count;
  }
  bucket_count = nelua_roundpow2(bucket_count);
  uintptr_t node_count = nelua_ceilidiv((bucket_count * 75U), 100U);
  if(((bucket_count > 0) && (node_count <= self->size))) {
    node_count = (self->size + 1);
  }
  if((((node_count < self->nodes.size) && (self->nodes.size > 0)) && (node_count > 0))) {
    uintptr_t j = 0U;
    while(((j < self->nodes.size) && (*nelua_span_hashmapnode_string__cint_____atindex(self->nodes, j)).filled)) {
      j = (j + 1);
    }
    for(uintptr_t i = j, _end = self->nodes.size; i < _end; i += 1) {
      if((*nelua_span_hashmapnode_string__cint_____atindex(self->nodes, i)).filled) {
        (*nelua_span_hashmapnode_string__cint_____atindex(self->nodes, j)) = (*nelua_span_hashmapnode_string__cint_____atindex(self->nodes, i));
        j = (j + 1);
      }
    }
    for(uintptr_t i = j, _end = self->nodes.size; i < _end; i += 1) {
      (*nelua_span_hashmapnode_string__cint_____atindex(self->nodes, i)) = (nelua_hashmapnode_string__cint_){0};
    }
  }
  self->nodes = nelua_GeneralAllocator_xspanrealloc0_1((&self->allocator), self->nodes, node_count);
  self->buckets = nelua_GeneralAllocator_xspanrealloc_3((&self->allocator), self->buckets, bucket_count);
  nelua_memory_spanset_1(self->buckets, 0xffffffffffffffffULL);
  uintptr_t free_index = 0xffffffffffffffffULL;
  for(intptr_t i = (intptr_t)(self->nodes.size - 1); i >= 0; i += -1) {
    nelua_hashmapnode_string__cint__ptr node = (&(*nelua_span_hashmapnode_string__cint_____atindex(self->nodes, (uintptr_t)i)));
    if(node->filled) {
      node->next = 0xffffffffffffffffULL;
    } else {
      node->next = free_index;
      free_index = (uintptr_t)i;
    }
  }
  self->free_index = free_index;
  for(uintptr_t i = 0U, _end = self->nodes.size; i < _end; i += 1) {
    if((*nelua_span_hashmapnode_string__cint_____atindex(self->nodes, i)).filled) {
      nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_string__cint___find(self, (*nelua_span_hashmapnode_string__cint_____atindex(self->nodes, i)).key);
      uintptr_t node_index = _asgnret_1.r1;
      uintptr_t prev_node_index = _asgnret_1.r2;
      uintptr_t bucket_index = _asgnret_1.r3;
      if(NELUA_LIKELY((prev_node_index == 0xffffffffffffffffULL))) {
        (*nelua_span_usize____atindex(self->buckets, bucket_index)) = i;
      } else {
        (*nelua_span_hashmapnode_string__cint_____atindex(self->nodes, prev_node_index)).next = i;
      }
      (*nelua_span_hashmapnode_string__cint_____atindex(self->nodes, i)).next = node_index;
    }
  }
}
uintptr_t nelua_hashmap_string__cint___at(nelua_hashmap_string__cint__ptr self, nlstring key) {
  if(NELUA_UNLIKELY((self->buckets.size == 0))) {
    nelua_hashmap_string__cint__rehash(self, 8U);
  }
  nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_string__cint___find(self, key);
  uintptr_t node_index = _asgnret_1.r1;
  uintptr_t prev_node_index = _asgnret_1.r2;
  uintptr_t bucket_index = _asgnret_1.r3;
  if((node_index != 0xffffffffffffffffULL)) {
    return node_index;
  } else {
    uintptr_t node_index_1 = self->free_index;
    nelua_hashmapnode_string__cint__ptr node = (&(*nelua_span_hashmapnode_string__cint_____atindex(self->nodes, node_index_1)));
    self->free_index = node->next;
    (*node) = (nelua_hashmapnode_string__cint_){.key = key, .filled = true, .next = 0xffffffffffffffffULL};
    if(NELUA_LIKELY((prev_node_index == 0xffffffffffffffffULL))) {
      (*nelua_span_usize____atindex(self->buckets, bucket_index)) = node_index_1;
    } else {
      (*nelua_span_hashmapnode_string__cint_____atindex(self->nodes, prev_node_index)).next = node_index_1;
    }
    self->size = (self->size + 1);
    if(NELUA_UNLIKELY(((self->size * 100) >= (self->buckets.size * 75U)))) {
      nelua_hashmap_string__cint__rehash(self, nelua_ceilidiv((self->size * 200U), 75U));
    }
    return node_index_1;
  }
}
nlcint_ptr nelua_hashmap_string__cint____atindex(nelua_hashmap_string__cint__ptr self, nlstring key) {
  return (&(*nelua_span_hashmapnode_string__cint_____atindex(self->nodes, nelua_hashmap_string__cint___at(self, key))).value);
}
nlcint_ptr nelua_hashmap_string__cint__peek(nelua_hashmap_string__cint__ptr self, nlstring key) {
  uintptr_t node_index = nelua_hashmap_string__cint___find(self, key).r1;
  if((node_index != 0xffffffffffffffffULL)) {
    return (&(*nelua_span_hashmapnode_string__cint_____atindex(self->nodes, node_index)).value);
  }
  return (nlcint_ptr)NULL;
}
bool nelua_hashmap_string__cint__has(nelua_hashmap_string__cint__ptr self, nlstring key) {
  return (nelua_hashmap_string__cint__peek(self, key) != (nlcint_ptr)NULL);
}
void bwrapbox_fail_1(nlstring msg) {
  nelua_filestream_writef_3((&nelua_io_stderr), msg);
  nelua_filestream_write_1((&nelua_io_stderr), ((nlstring){(uint8_t*)"\n", 1}));
  nelua_filestream_flush((&nelua_io_stderr));
  if(bwrapbox_is_child) {
    _exit(-1);
  } else {
    exit(-1);
  }
}
void bwrapbox_fail_2(nlstring msg, int __arg1) {
  nelua_filestream_writef_4((&nelua_io_stderr), msg, __arg1);
  nelua_filestream_write_1((&nelua_io_stderr), ((nlstring){(uint8_t*)"\n", 1}));
  nelua_filestream_flush((&nelua_io_stderr));
  if(bwrapbox_is_child) {
    _exit(-1);
  } else {
    exit(-1);
  }
}
void bwrapbox_fail_3(nlstring msg, nlstring __arg1, nlstring __arg2) {
  nelua_filestream_writef_5((&nelua_io_stderr), msg, __arg1, __arg2);
  nelua_filestream_write_1((&nelua_io_stderr), ((nlstring){(uint8_t*)"\n", 1}));
  nelua_filestream_flush((&nelua_io_stderr));
  if(bwrapbox_is_child) {
    _exit(-1);
  } else {
    exit(-1);
  }
}
void bwrapbox_fail_4(nlstring msg, int __arg1, nlstring __arg2, nlstring __arg3) {
  nelua_filestream_writef_6((&nelua_io_stderr), msg, __arg1, __arg2, __arg3);
  nelua_filestream_write_1((&nelua_io_stderr), ((nlstring){(uint8_t*)"\n", 1}));
  nelua_filestream_flush((&nelua_io_stderr));
  if(bwrapbox_is_child) {
    _exit(-1);
  } else {
    exit(-1);
  }
}
void bwrapbox_fail_5(nlstring msg, nlstring __arg1) {
  nelua_filestream_writef_7((&nelua_io_stderr), msg, __arg1);
  nelua_filestream_write_1((&nelua_io_stderr), ((nlstring){(uint8_t*)"\n", 1}));
  nelua_filestream_flush((&nelua_io_stderr));
  if(bwrapbox_is_child) {
    _exit(-1);
  } else {
    exit(-1);
  }
}
void bwrapbox_fail_6(nlstring msg, nlstring __arg1, nlstring __arg2, nlstring __arg3) {
  nelua_filestream_writef_8((&nelua_io_stderr), msg, __arg1, __arg2, __arg3);
  nelua_filestream_write_1((&nelua_io_stderr), ((nlstring){(uint8_t*)"\n", 1}));
  nelua_filestream_flush((&nelua_io_stderr));
  if(bwrapbox_is_child) {
    _exit(-1);
  } else {
    exit(-1);
  }
}
void bwrapbox_fail_7(nlstring msg, nlstring __arg1, int64_t __arg2) {
  nelua_filestream_writef_9((&nelua_io_stderr), msg, __arg1, __arg2);
  nelua_filestream_write_1((&nelua_io_stderr), ((nlstring){(uint8_t*)"\n", 1}));
  nelua_filestream_flush((&nelua_io_stderr));
  if(bwrapbox_is_child) {
    _exit(-1);
  } else {
    exit(-1);
  }
}
void nelua_panic_cstring(const char* s) {
  if(s) {
    nelua_write_stderr(s, strlen(s), true);
  }
  nelua_abort();
}
int64_t nelua_idiv_nlint64(int64_t a, int64_t b) {
  if(NELUA_UNLIKELY(b == -1)) return 0U - (uint64_t)a;
  if(NELUA_UNLIKELY(b == 0)) nelua_panic_cstring("division by zero");
  int64_t q = a / b;
  return q * b == a ? q : q - ((a < 0) ^ (b < 0));
}
int64_t nelua_imod_nlint64(int64_t a, int64_t b) {
  if(NELUA_UNLIKELY(b == -1)) return 0;
  int64_t r = a % b;
  return (r != 0 && (a ^ b) < 0) ? r + b : r;
}
void bwrapbox_usleep(int64_t usecs) {
  if((usecs <= 0)) {
    return;
  }
  nanosleep(NELUA_LITERAL_REF(timespec_t, ((timespec_t){.tv_sec = (time_t)nelua_idiv_nlint64(usecs, 1000000), .tv_nsec = (long)(nelua_imod_nlint64(usecs, 1000000) * 1000)})), ((timespec_t_ptr)NULL));
}
nlmulret_nlcint_nlstring bwrapbox_wait_child_pid(int pid) {
  int status = 0;
  if((waitpid(pid, (&status), 0) != pid)) {
    bwrapbox_fail_1(((nlstring){(uint8_t*)"failed to wait child pid", 24}));
  }
  if(WIFEXITED(status)) {
    status = WEXITSTATUS(status);
    return (nlmulret_nlcint_nlstring){status, ((nlstring){(uint8_t*)"exited", 6})};
  } else if(WIFSIGNALED(status)) {
    status = WTERMSIG(status);
    return (nlmulret_nlcint_nlstring){status, ((nlstring){(uint8_t*)"killed", 6})};
  } else if(WIFSTOPPED(status)) {
    status = WSTOPSIG(status);
    return (nlmulret_nlcint_nlstring){status, ((nlstring){(uint8_t*)"stopped", 7})};
  } else {
    bwrapbox_fail_2(((nlstring){(uint8_t*)"unhandled wait status %d", 24}), status);
    return (nlmulret_nlcint_nlstring){-1, ((nlstring){(uint8_t*)"", 0})};
  }
}
char* nelua_string2cstring(nlstring s) {
  return (s.size == 0) ? (char*)"" : (char*)s.data;
}
bool bwrapbox_isdir(nlstring path) {
  stat_t st = (stat_t){0};
  return ((stat(nelua_string2cstring(path), (&st)) == 0) && S_ISDIR(st.st_mode));
}
nlmulret_nlboolean_nlstring_nlint64 bwrapbox_result_from_errno(bool ok) {
  if((!ok)) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, nelua_cstring2string(strerror(errno)), (int64_t)errno};
  }
  return (nlmulret_nlboolean_nlstring_nlint64){true, (nlstring){0}, 0};
}
nlmulret_nlboolean_nlstring_nlint64 bwrapbox_fs_mkdir(nlstring path) {
  unsigned int mode = (((((((S_IRUSR | S_IWUSR) | S_IXUSR) | S_IRGRP) | S_IWGRP) | S_IXGRP) | S_IROTH) | S_IXOTH);
  nlmulret_nlboolean_nlstring_nlint64 _ret_1 = bwrapbox_result_from_errno((mkdir(nelua_string2cstring(path), mode) == 0));
  return (nlmulret_nlboolean_nlstring_nlint64){_ret_1.r1, _ret_1.r2, _ret_1.r3};
}
nlmulret_nlboolean_nlstring_nlint64 bwrapbox_fs_rmdir(nlstring path) {
  nlmulret_nlboolean_nlstring_nlint64 _ret_1 = bwrapbox_result_from_errno((rmdir(nelua_string2cstring(path)) == 0));
  return (nlmulret_nlboolean_nlstring_nlint64){_ret_1.r1, _ret_1.r2, _ret_1.r3};
}
nlmulret_nlboolean_nlstring_nlint64 bwrapbox_fs_mkfile(nlstring path, nlstring contents) {
  int fd = open(nelua_string2cstring(path), ((O_CREAT | O_WRONLY) | O_TRUNC), ((((S_IRUSR | S_IWUSR) | S_IRGRP) | S_IWGRP) | S_IROTH));
  if((fd < 0)) {
    nlmulret_nlboolean_nlstring_nlint64 _ret_1 = bwrapbox_result_from_errno(false);
    return (nlmulret_nlboolean_nlstring_nlint64){_ret_1.r1, _ret_1.r2, _ret_1.r3};
  }
  if((contents.size > 0)) {
    uintptr_t writtenbytes = 0U;
    {
      bool _repeat_stop;
      do {
        uintptr_t remaining = (contents.size - writtenbytes);
        if((remaining > 4096)) {
          remaining = 4096U;
        }
        intptr_t writebytes = (intptr_t)write(fd, (void*)(&contents.data[writtenbytes]), (size_t)remaining);
        if((writebytes < 0)) {
          nlmulret_nlboolean_nlstring_nlint64 _mulret_1;
          nlmulret_nlboolean_nlstring_nlint64 _ret_2 = bwrapbox_result_from_errno(false);
          _mulret_1.r1 = _ret_2.r1;
          _mulret_1.r2 = _ret_2.r2;
          _mulret_1.r3 = _ret_2.r3;
          { /* defer */
            close(fd);
          }
          return _mulret_1;
        }
        writtenbytes = (writtenbytes + (uintptr_t)writebytes);
        _repeat_stop = (writtenbytes >= contents.size);
      } while(!_repeat_stop);
    }
  }
  nlmulret_nlboolean_nlstring_nlint64 _mulret_2;
  _mulret_2.r1 = true;
  _mulret_2.r2 = (nlstring){0};
  _mulret_2.r3 = 0;
  { /* defer */
    close(fd);
  }
  return _mulret_2;
}
nlmulret_nlstring_nlstring_nlint64 bwrapbox_fs_readfile(nlstring path) {
  int fd = open(nelua_string2cstring(path), O_RDONLY, 0U);
  if((fd < 0)) {
    return (nlmulret_nlstring_nlstring_nlint64){(nlstring){0}, nelua_cstring2string(strerror(errno)), (int64_t)errno};
  }
  nelua_stringbuilderT sb = (nelua_stringbuilderT){0};
  {
    bool _repeat_stop;
    do {
      nelua_span_uint8_ p = nelua_stringbuilderT_prepare((&sb), 4096U);
      if(nelua_span_uint8__empty(p)) {
        nelua_stringbuilderT_destroy((&sb));
        nlmulret_nlstring_nlstring_nlint64 _mulret_1;
        _mulret_1.r1 = (nlstring){0};
        _mulret_1.r2 = ((nlstring){(uint8_t*)"out of buffer memory", 20});
        _mulret_1.r3 = -1;
        { /* defer */
          close(fd);
        }
        return _mulret_1;
      }
      intptr_t nr = (intptr_t)read(fd, (void*)p.data, 4096U);
      if((nr < 0)) {
        nelua_stringbuilderT_destroy((&sb));
        nlmulret_nlstring_nlstring_nlint64 _mulret_2;
        _mulret_2.r1 = (nlstring){0};
        _mulret_2.r2 = nelua_cstring2string(strerror(errno));
        _mulret_2.r3 = (int64_t)errno;
        { /* defer */
          close(fd);
        }
        return _mulret_2;
      }
      nelua_stringbuilderT_commit((&sb), (uintptr_t)nr);
      _repeat_stop = (nr < 4096);
    } while(!_repeat_stop);
  }
  nlmulret_nlstring_nlstring_nlint64 _mulret_3;
  _mulret_3.r1 = nelua_stringbuilderT_promote((&sb));
  _mulret_3.r2 = (nlstring){0};
  _mulret_3.r3 = 0;
  { /* defer */
    close(fd);
  }
  return _mulret_3;
}
void bwrapbox_cgroup_create(nlstring cgroup_path) {
  nlmulret_nlboolean_nlstring_nlint64 _asgnret_1 = bwrapbox_fs_mkdir(cgroup_path);
  bool ok = _asgnret_1.r1;
  nlstring err = _asgnret_1.r2;
  if((!ok)) {
    bwrapbox_fail_3(((nlstring){(uint8_t*)"failed to create cgroup '%s': %s", 32}), cgroup_path, err);
  }
}
void bwrapbox_cgroup_kill_and_destroy(nlstring cgroup_path) {
  if(bwrapbox_isdir(cgroup_path)) {
    nlstring kill_path = nelua_nlstring___concat_2(cgroup_path, ((nlstring){(uint8_t*)"/cgroup.kill", 12}));
    bwrapbox_fs_mkfile(kill_path, ((nlstring){(uint8_t*)"1", 1}));
    nlstring procs_path = nelua_nlstring___concat_2(cgroup_path, ((nlstring){(uint8_t*)"/cgroup.procs", 13}));
    {
      bool _repeat_stop;
      do {
        nlstring contents = bwrapbox_fs_readfile(procs_path).r1;
        _repeat_stop = (nelua_nlstring___len(contents) == 0);
        { /* defer */
          nelua_nlstring___close((&contents));
        }
      } while(!_repeat_stop);
    }
    nlmulret_nlboolean_nlstring_nlint64 _asgnret_1 = bwrapbox_fs_rmdir(cgroup_path);
    bool ok = _asgnret_1.r1;
    nlstring err = _asgnret_1.r2;
    if((!ok)) {
      bwrapbox_fail_3(((nlstring){(uint8_t*)"failed to destroy cgroup '%s': %s", 33}), cgroup_path, err);
    }
    { /* defer */
      nelua_nlstring___close((&procs_path));
    }
    { /* defer */
      nelua_nlstring___close((&kill_path));
    }
  }
}
void bwrapbox_cgroup_set_limits(nlstring cgroup_path, nelua_sequence_limit_pair_ limits) {
  {
    nlmulret_function_3cvqKRRWFe2qk8ZgD_nelua_sequence_limit_pair__nlint64 _asgnret_1 = nelua_ipairs_1(limits);
    function_3cvqKRRWFe2qk8ZgD __fornext = _asgnret_1.r1;
    nelua_sequence_limit_pair_ __forstate = _asgnret_1.r2;
    int64_t __fornextit = _asgnret_1.r3;
    while(true) {
      nlmulret_nlboolean_nlint64_bwrapbox_limit_pair _asgnret_2 = __fornext(__forstate, __fornextit);
      bool __forcont = _asgnret_2.r1;
      int64_t i = _asgnret_2.r2;
      bwrapbox_limit_pair limit = _asgnret_2.r3;
      if((!__forcont)) {
        break;
      }
      __fornextit = i;
      {
        nlstring path = nelua_nlstring_concat_1(nelua_span_string____convert_1(NELUA_LITERAL_REF(nlstring_arr3, ((nlstring_arr3){{cgroup_path, {(uint8_t*)"/", 1}, limit.name}}))), NELUA_NIL);
        nlstring content = nelua_tostring_4(limit.value);
        nlmulret_nlboolean_nlstring_nlint64 _asgnret_3 = bwrapbox_fs_mkfile(path, content);
        bool ok = _asgnret_3.r1;
        nlstring err = _asgnret_3.r2;
        if((!ok)) {
          bwrapbox_fail_6(((nlstring){(uint8_t*)"failed to set cgroup '%s' limit '%s': %s", 40}), cgroup_path, limit.name, err);
        }
        { /* defer */
          nelua_nlstring___close((&content));
        }
        { /* defer */
          nelua_nlstring___close((&path));
        }
      }
    }
  }
}
void bwrapbox_cgroup_migrate_pid(nlstring cgroup_path, int pid) {
  nlstring procs_path = nelua_nlstring___concat_2(cgroup_path, ((nlstring){(uint8_t*)"/cgroup.procs", 13}));
  nlstring content = nelua_nlstring_format_2(((nlstring){(uint8_t*)"%d\n", 3}), pid);
  nlmulret_nlboolean_nlstring_nlint64 _asgnret_1 = bwrapbox_fs_mkfile(procs_path, content);
  bool ok = _asgnret_1.r1;
  nlstring err = _asgnret_1.r2;
  if((!ok)) {
    bwrapbox_fail_4(((nlstring){(uint8_t*)"failed to migrate pid %d to create cgroup '%s': %s", 50}), pid, cgroup_path, err);
  }
  { /* defer */
    nelua_nlstring___close((&content));
  }
  { /* defer */
    nelua_nlstring___close((&procs_path));
  }
}
int64_t bwrapbox_cgroup_cputime_usecs(nlstring cgroup_path) {
  nlstring path = nelua_nlstring___concat_2(cgroup_path, ((nlstring){(uint8_t*)"/cpu.stat", 9}));
  nlstring contents = bwrapbox_fs_readfile(path).r1;
  if((nelua_nlstring___len(contents) == 0)) {
    { /* defer */
      nelua_nlstring___close((&contents));
    }
    { /* defer */
      nelua_nlstring___close((&path));
    }
    return -1;
  }
  nlstring usecs = nelua_nlstring_gsub_1(contents, ((nlstring){(uint8_t*)"^usage_usec ([0-9]+).*$", 23}), ((nlstring){(uint8_t*)"%1", 2}), NELUA_NIL).r1;
  int64_t _ret_1 = nelua_tointeger_1(usecs, NELUA_NIL);
  { /* defer */
    nelua_nlstring___close((&usecs));
  }
  { /* defer */
    nelua_nlstring___close((&contents));
  }
  { /* defer */
    nelua_nlstring___close((&path));
  }
  return _ret_1;
}
void bwrapbox_print_help(nlstring arg0) {
  nelua_filestream_write_1((&nelua_io_stdout), nelua_nlstring___concat_2(((nlstring){(uint8_t*)"usage: ", 7}), nelua_nlstring___concat_2(arg0, ((nlstring){(uint8_t*)nelua_strlit_1, 755}))));
}
nelua_sequence_cstring_ bwrapbox_parse_args(void) {
  nelua_sequence_cstring_ bwrap_args = (nelua_sequence_cstring_){0};
  (*nelua_sequence_cstring____atindex((&bwrap_args), 0U)) = (char*)"bwrap";
  bool help = (nelua_sequence_string__1___len((&nelua_arg)) == 0);
  if((!help)) {
    {
      nlmulret_function_36ho9doMFPJUp2PPv_nelua_sequence_string__1_nlint64 _asgnret_1 = nelua_ipairs_2(nelua_arg);
      function_36ho9doMFPJUp2PPv __fornext = _asgnret_1.r1;
      nelua_sequence_string__1 __forstate = _asgnret_1.r2;
      int64_t __fornextit = _asgnret_1.r3;
      while(true) {
        nlmulret_nlboolean_nlint64_nlstring _asgnret_2 = __fornext(__forstate, __fornextit);
        bool __forcont = _asgnret_2.r1;
        int64_t _ = _asgnret_2.r2;
        nlstring arg_1 = _asgnret_2.r3;
        if((!__forcont)) {
          break;
        }
        __fornextit = _;
        {
          if(nelua_nlstring___eq(arg_1, ((nlstring){(uint8_t*)"--help", 6}))) {
            help = true;
            break;
          }
        }
      }
    }
  }
  if(help) {
    bwrapbox_print_help((*nelua_sequence_string__1___atindex((&nelua_arg), 0U)));
    nelua_sequence_cstring__push((&bwrap_args), nelua_string2cstring(((nlstring){(uint8_t*)"--help", 6})));
    nelua_sequence_cstring__push((&bwrap_args), (char*)NULL);
    return bwrap_args;
  }
  bool ignore = false;
  int64_t i = 1;
  while((i <= nelua_sequence_string__1___len((&nelua_arg)))) {
    if(nelua_nlstring___eq((*nelua_sequence_string__1___atindex((&nelua_arg), (uintptr_t)i)), ((nlstring){(uint8_t*)"--", 2}))) {
      nelua_sequence_cstring__push((&bwrap_args), nelua_string2cstring((*nelua_sequence_string__1___atindex((&nelua_arg), (uintptr_t)i))));
      ignore = true;
    } else if((nelua_nlstring___eq((*nelua_sequence_string__1___atindex((&nelua_arg), (uintptr_t)i)), ((nlstring){(uint8_t*)"--cgroup", 8})) && (!ignore))) {
      bwrapbox_cgroup_path = (*nelua_sequence_string__1___atindex((&nelua_arg), (uintptr_t)(i + 1)));
      if(((nelua_nlstring___len(bwrapbox_cgroup_path) > 0) && ((*nelua_nlstring___atindex(bwrapbox_cgroup_path, 1U)) != 47U))) {
        bwrapbox_cgroup_path = nelua_nlstring___concat_2(((nlstring){(uint8_t*)"/sys/fs/cgroup/", 15}), bwrapbox_cgroup_path);
      }
      i = (i + 1);
      bwrapbox_cgroup_enabled = true;
    } else if((nelua_nlstring___eq((*nelua_sequence_string__1___atindex((&nelua_arg), (uintptr_t)i)), ((nlstring){(uint8_t*)"--cgroup-overwrite", 18})) && (!ignore))) {
      bwrapbox_cgroup_overwrite = true;
    } else if((nelua_nlstring___eq((*nelua_sequence_string__1___atindex((&nelua_arg), (uintptr_t)i)), ((nlstring){(uint8_t*)"--climit", 8})) && (!ignore))) {
      nlstring name = (*nelua_sequence_string__1___atindex((&nelua_arg), (uintptr_t)(i + 1)));
      int64_t value = nelua_tointeger_1((*nelua_sequence_string__1___atindex((&nelua_arg), (uintptr_t)(i + 2))), NELUA_NIL);
      if(nelua_nlstring___eq(name, ((nlstring){(uint8_t*)"time.high", 9}))) {
        bwrapbox_cgroup_high_usecs = value;
      } else if(nelua_nlstring___eq(name, ((nlstring){(uint8_t*)"time.max", 8}))) {
        bwrapbox_cgroup_max_usecs = value;
      } else {
        nelua_sequence_limit_pair__push((&bwrapbox_cgroup_limits), (bwrapbox_limit_pair){.name = name, .value = value});
      }
      i = (i + 2);
    } else if((nelua_nlstring___eq((*nelua_sequence_string__1___atindex((&nelua_arg), (uintptr_t)i)), ((nlstring){(uint8_t*)"--rlimit", 8})) && (!ignore))) {
      nelua_sequence_limit_pair__push((&bwrapbox_exec_limits), ({
        bwrapbox_limit_pair _tmp = {0};
        _tmp.name = (*nelua_sequence_string__1___atindex((&nelua_arg), (uintptr_t)(i + 1)));
        _tmp.value = nelua_tointeger_1((*nelua_sequence_string__1___atindex((&nelua_arg), (uintptr_t)(i + 2))), NELUA_NIL);
        _tmp;
      }));
      i = (i + 2);
    } else if((nelua_nlstring___eq((*nelua_sequence_string__1___atindex((&nelua_arg), (uintptr_t)i)), ((nlstring){(uint8_t*)"--climit-elapsed-high", 21})) && (!ignore))) {
      if((!bwrapbox_cgroup_enabled)) {
        bwrapbox_fail_1(((nlstring){(uint8_t*)"enable cgroup to limit time", 27}));
      }
      bwrapbox_elapsed_high_limit_usecs = nelua_tointeger_1((*nelua_sequence_string__1___atindex((&nelua_arg), (uintptr_t)(i + 1))), NELUA_NIL);
      i = (i + 1);
    } else if((nelua_nlstring___eq((*nelua_sequence_string__1___atindex((&nelua_arg), (uintptr_t)i)), ((nlstring){(uint8_t*)"--climit-elapsed-max", 20})) && (!ignore))) {
      if((!bwrapbox_cgroup_enabled)) {
        bwrapbox_fail_1(((nlstring){(uint8_t*)"enable cgroup to limit time", 27}));
      }
      bwrapbox_elapsed_max_limit_usecs = nelua_tointeger_1((*nelua_sequence_string__1___atindex((&nelua_arg), (uintptr_t)(i + 1))), NELUA_NIL);
      i = (i + 1);
    } else if((nelua_nlstring___eq((*nelua_sequence_string__1___atindex((&nelua_arg), (uintptr_t)i)), ((nlstring){(uint8_t*)"--setuid", 8})) && (!ignore))) {
      bwrapbox_exec_uid = (uint32_t)nelua_tointeger_1((*nelua_sequence_string__1___atindex((&nelua_arg), (uintptr_t)(i + 1))), NELUA_NIL);
      i = (i + 1);
    } else if((nelua_nlstring___eq((*nelua_sequence_string__1___atindex((&nelua_arg), (uintptr_t)i)), ((nlstring){(uint8_t*)"--setgid", 8})) && (!ignore))) {
      bwrapbox_exec_gid = (uint32_t)nelua_tointeger_1((*nelua_sequence_string__1___atindex((&nelua_arg), (uintptr_t)(i + 1))), NELUA_NIL);
      i = (i + 1);
    } else if((nelua_nlstring___eq((*nelua_sequence_string__1___atindex((&nelua_arg), (uintptr_t)i)), ((nlstring){(uint8_t*)"--quiet", 7})) && (!ignore))) {
      bwrapbox_quiet = true;
    } else {
      nelua_sequence_cstring__push((&bwrap_args), nelua_string2cstring((*nelua_sequence_string__1___atindex((&nelua_arg), (uintptr_t)i))));
    }
    i = (i + 1);
  }
  nelua_sequence_cstring__push((&bwrap_args), (char*)NULL);
  return bwrap_args;
}
void bwrapbox_set_rlimits(nelua_sequence_limit_pair_ limits) {
  {
    nlmulret_function_3cvqKRRWFe2qk8ZgD_nelua_sequence_limit_pair__nlint64 _asgnret_1 = nelua_ipairs_1(limits);
    function_3cvqKRRWFe2qk8ZgD __fornext = _asgnret_1.r1;
    nelua_sequence_limit_pair_ __forstate = _asgnret_1.r2;
    int64_t __fornextit = _asgnret_1.r3;
    while(true) {
      nlmulret_nlboolean_nlint64_bwrapbox_limit_pair _asgnret_2 = __fornext(__forstate, __fornextit);
      bool __forcont = _asgnret_2.r1;
      int64_t i = _asgnret_2.r2;
      bwrapbox_limit_pair limit = _asgnret_2.r3;
      if((!__forcont)) {
        break;
      }
      __fornextit = i;
      {
        intptr_t dotpos = nelua_nlstring_find_1(limit.name, ((nlstring){(uint8_t*)".", 1}), 1, true).r1;
        if((dotpos <= 0)) {
          bwrapbox_fail_5(((nlstring){(uint8_t*)"invalid rlimit '%s'", 19}), limit.name);
        }
        nlstring name = nelua_nlstring_subview_1(limit.name, 1, (dotpos - 1));
        nlstring suffix = nelua_nlstring_subview_1(limit.name, (dotpos + 1), -1);
        if(((!nelua_hashmap_string__cint__has((&bwrapbox_rlimit_map), name)) || (!(nelua_nlstring___eq(suffix, ((nlstring){(uint8_t*)"high", 4})) || nelua_nlstring___eq(suffix, ((nlstring){(uint8_t*)"max", 3})))))) {
          bwrapbox_fail_5(((nlstring){(uint8_t*)"invalid rlimit '%s'", 19}), limit.name);
        }
        int resid = (*nelua_hashmap_string__cint____atindex((&bwrapbox_rlimit_map), name));
        rlimit_t rlim = (rlimit_t){0};
        if((getrlimit(resid, (&rlim)) < 0)) {
          bwrapbox_fail_5(((nlstring){(uint8_t*)"failed to get rlimit '%s'", 25}), name);
        }
        unsigned long value = (unsigned long)limit.value;
        if(nelua_nlstring___eq(suffix, ((nlstring){(uint8_t*)"high", 4}))) {
          rlim.rlim_cur = value;
        } else {
          rlim.rlim_max = value;
          if((rlim.rlim_cur > rlim.rlim_max)) {
            rlim.rlim_cur = rlim.rlim_max;
          }
        }
        if((setrlimit(resid, (&rlim)) < 0)) {
          bwrapbox_fail_7(((nlstring){(uint8_t*)"failed to set rlim '%s' to %d", 29}), name, limit.value);
        }
      }
    }
  }
}
void bwrapbox_bwrap_exec(nelua_sequence_cstring_ args, nelua_sequence_limit_pair_ rlimits, uint32_t uid, uint32_t gid) {
  bwrapbox_set_rlimits(rlimits);
  if(((gid != 0xffffffffLL) && (getgid() != gid))) {
    if((setgid((unsigned int)gid) < 0)) {
      bwrapbox_fail_1(((nlstring){(uint8_t*)"setgid failed", 13}));
    }
  }
  if(((uid != 0xffffffffLL) && (getuid() != uid))) {
    if((setuid((unsigned int)uid) < 0)) {
      bwrapbox_fail_1(((nlstring){(uint8_t*)"setuid failed", 13}));
    }
  }
  if((({
    char* _tmp1 = (*nelua_sequence_cstring____atindex((&args), 0U));
    nlcstring_ptr _tmp2 = (&(*nelua_sequence_cstring____atindex((&args), 0U)));
    execvp(_tmp1, ((nlcstring_arr0_ptr)_tmp2));
  }) < 0)) {
    bwrapbox_fail_1(((nlstring){(uint8_t*)"failed to exec bwrap", 20}));
  }
  nelua_panic_string((nlstring){0});
}
void bwrapbox_cgroup_wait_time_and_kill(nlstring cgroup_path_1, int64_t cpu_max_usecs, int64_t time_max_usecs, int pid, int sig) {
  while(true) {
    int64_t elapsed_usec = (int64_t)(nelua_os_now() * 1000000.0);
    int64_t usage_usec = bwrapbox_cgroup_cputime_usecs(cgroup_path_1);
    if((usage_usec < 0)) {
      return;
    }
    if((((cpu_max_usecs >= 0) && (usage_usec >= cpu_max_usecs)) || ((time_max_usecs >= 0) && (elapsed_usec >= time_max_usecs)))) {
      kill(pid, sig);
      return;
    } else {
      int64_t wait_usecs = 0x7fffffffffffffffLL;
      if((cpu_max_usecs >= 0)) {
        wait_usecs = nelua_math_min_1(wait_usecs, nelua_math_max_1((cpu_max_usecs - usage_usec), 0));
      }
      if((time_max_usecs >= 0)) {
        wait_usecs = nelua_math_min_1(wait_usecs, nelua_math_max_1((time_max_usecs - elapsed_usec), 0));
      }
      bwrapbox_usleep(wait_usecs);
    }
  }
}
void bwrapbox_after_fork(void) {
  if((prctl(PR_SET_PDEATHSIG, (unsigned long)SIGKILL, 0U, 0U, 0U) != 0)) {
    bwrapbox_fail_1(((nlstring){(uint8_t*)"prctl() with PR_SET_PDEATHSIG failed", 36}));
  }
}
int bwrapbox_fork_cgroup_time_limiter(nlstring cgroup_path_2, int64_t cpu_high_usecs, int64_t cpu_max_usecs, int64_t time_high_usecs, int64_t time_max_usecs, int kill_pid) {
  if(((((cpu_high_usecs < 0) && (cpu_max_usecs < 0)) && (time_high_usecs < 0)) && (time_max_usecs < 0))) {
    return -1;
  }
  int pid = fork();
  if((pid == 0)) {
    bwrapbox_is_child = true;
    bwrapbox_after_fork();
    if(((cpu_high_usecs >= 0) || (time_high_usecs >= 0))) {
      if(((cpu_high_usecs == -1) || ((cpu_max_usecs >= 0) && (cpu_max_usecs < cpu_high_usecs)))) {
        cpu_high_usecs = cpu_max_usecs;
      }
      if(((time_high_usecs == -1) || ((time_max_usecs >= 0) && (time_max_usecs < time_high_usecs)))) {
        time_high_usecs = time_max_usecs;
      }
      bwrapbox_cgroup_wait_time_and_kill(cgroup_path_2, cpu_high_usecs, time_high_usecs, kill_pid, SIGXCPU);
    }
    if(((cpu_max_usecs >= 0) || (time_max_usecs >= 0))) {
      bwrapbox_cgroup_wait_time_and_kill(cgroup_path_2, cpu_max_usecs, time_max_usecs, kill_pid, SIGKILL);
    }
    _exit(0);
  } else if((pid < 0)) {
    bwrapbox_fail_1(((nlstring){(uint8_t*)"limiter fork() failed", 21}));
  }
  return pid;
}
int bwrapbox_fork_cgroup_bwrap_exec(nlstring cgroup_path_3, nelua_sequence_cstring_ args, nelua_sequence_limit_pair_ rlimits, uint32_t uid, uint32_t gid) {
  int pid = fork();
  if((pid == 0)) {
    bwrapbox_is_child = true;
    bwrapbox_after_fork();
    bwrapbox_cgroup_migrate_pid(cgroup_path_3, getpid());
    bwrapbox_bwrap_exec(args, rlimits, uid, gid);
  } else if((pid < 0)) {
    bwrapbox_fail_1(((nlstring){(uint8_t*)"bwrap fork() failed", 19}));
  }
  return pid;
}
void bwrapbox_cleanup_cgroup(void) {
  bwrapbox_cgroup_kill_and_destroy(bwrapbox_cgroup_path);
}
void bwrapbox_signal_handler(int signum) {
  bwrapbox_cleanup_cgroup();
}
int nelua_main(int argc, char** argv) {
  nelua_argc = argc;
  nelua_argv = argv;
  nelua_require_io(NELUA_NIL);
  nelua_require_arg(NELUA_NIL);
  (*nelua_hashmap_string__cint____atindex((&bwrapbox_rlimit_map), ((nlstring){(uint8_t*)"cpu", 3}))) = 0;
  (*nelua_hashmap_string__cint____atindex((&bwrapbox_rlimit_map), ((nlstring){(uint8_t*)"fsize", 5}))) = 1;
  (*nelua_hashmap_string__cint____atindex((&bwrapbox_rlimit_map), ((nlstring){(uint8_t*)"data", 4}))) = 2;
  (*nelua_hashmap_string__cint____atindex((&bwrapbox_rlimit_map), ((nlstring){(uint8_t*)"stack", 5}))) = 3;
  (*nelua_hashmap_string__cint____atindex((&bwrapbox_rlimit_map), ((nlstring){(uint8_t*)"core", 4}))) = 4;
  (*nelua_hashmap_string__cint____atindex((&bwrapbox_rlimit_map), ((nlstring){(uint8_t*)"rss", 3}))) = 5;
  (*nelua_hashmap_string__cint____atindex((&bwrapbox_rlimit_map), ((nlstring){(uint8_t*)"nproc", 5}))) = 6;
  (*nelua_hashmap_string__cint____atindex((&bwrapbox_rlimit_map), ((nlstring){(uint8_t*)"nofile", 6}))) = 7;
  (*nelua_hashmap_string__cint____atindex((&bwrapbox_rlimit_map), ((nlstring){(uint8_t*)"memlock", 7}))) = 8;
  (*nelua_hashmap_string__cint____atindex((&bwrapbox_rlimit_map), ((nlstring){(uint8_t*)"as", 2}))) = 9;
  (*nelua_hashmap_string__cint____atindex((&bwrapbox_rlimit_map), ((nlstring){(uint8_t*)"locks", 5}))) = 10;
  (*nelua_hashmap_string__cint____atindex((&bwrapbox_rlimit_map), ((nlstring){(uint8_t*)"sigpending", 10}))) = 11;
  (*nelua_hashmap_string__cint____atindex((&bwrapbox_rlimit_map), ((nlstring){(uint8_t*)"msgqueue", 8}))) = 12;
  (*nelua_hashmap_string__cint____atindex((&bwrapbox_rlimit_map), ((nlstring){(uint8_t*)"nice", 4}))) = 13;
  (*nelua_hashmap_string__cint____atindex((&bwrapbox_rlimit_map), ((nlstring){(uint8_t*)"rtprio", 6}))) = 14;
  (*nelua_hashmap_string__cint____atindex((&bwrapbox_rlimit_map), ((nlstring){(uint8_t*)"rttime", 6}))) = 15;
  bwrapbox_bwrap_args = bwrapbox_parse_args();
  if(bwrapbox_cgroup_enabled) {
    if(bwrapbox_cgroup_overwrite) {
      bwrapbox_cgroup_kill_and_destroy(bwrapbox_cgroup_path);
    }
    atexit(bwrapbox_cleanup_cgroup);
    bwrapbox_cgroup_create(bwrapbox_cgroup_path);
    bwrapbox_cgroup_set_limits(bwrapbox_cgroup_path, bwrapbox_cgroup_limits);
    int bwrap_pid = bwrapbox_fork_cgroup_bwrap_exec(bwrapbox_cgroup_path, bwrapbox_bwrap_args, bwrapbox_exec_limits, bwrapbox_exec_uid, bwrapbox_exec_gid);
    nelua_os_now();
    bwrapbox_fork_cgroup_time_limiter(bwrapbox_cgroup_path, bwrapbox_cgroup_high_usecs, bwrapbox_cgroup_max_usecs, bwrapbox_elapsed_high_limit_usecs, bwrapbox_elapsed_max_limit_usecs, bwrap_pid);
    sigaction(SIGTERM, NELUA_LITERAL_REF(sigaction_t, ((sigaction_t){.sa_handler = bwrapbox_signal_handler})), ((sigaction_t_ptr)NULL));
    sigaction(SIGINT, NELUA_LITERAL_REF(sigaction_t, ((sigaction_t){.sa_handler = bwrapbox_signal_handler})), ((sigaction_t_ptr)NULL));
    nlmulret_nlcint_nlstring _asgnret_1 = bwrapbox_wait_child_pid(bwrap_pid);
    int status = _asgnret_1.r1;
    nlstring reason = _asgnret_1.r2;
    int64_t cputime_usec = bwrapbox_cgroup_cputime_usecs(bwrapbox_cgroup_path);
    if((!bwrapbox_quiet)) {
      int64_t elapsed_usecs = (int64_t)(nelua_os_now() * 1000000.0);
      if((nelua_nlstring___eq(reason, ((nlstring){(uint8_t*)"killed", 6})) && (status == SIGXCPU))) {
        nelua_filestream_printf_1((&nelua_io_stderr), ((nlstring){(uint8_t*)"[bwrapbox] application time exceeded after %d real usecs and CPU %d usecs\n", 74}), elapsed_usecs, cputime_usec);
      } else {
        nelua_filestream_printf_2((&nelua_io_stderr), ((nlstring){(uint8_t*)"[bwrapbox] application %s with status %d after %d real usecs and CPU %d usecs\n", 78}), reason, status, elapsed_usecs, cputime_usec);
      }
    }
    exit(status);
  } else {
    bwrapbox_bwrap_exec(bwrapbox_bwrap_args, bwrapbox_exec_limits, bwrapbox_exec_uid, bwrapbox_exec_gid);
  }
  return 0;
}
int main(int argc, char** argv) {
  return nelua_main(argc, argv);
}
